# Created: 2026-02-09
# Kerne Protocol â€” Standalone AI Penetration Tester
# Uses Claude 4.6 (1M Context) via OpenRouter
# 
# Usage: python "penetration testing/kerne_pentest.py"

import os
import sys
import json
import glob
from datetime import datetime
from pathlib import Path

try:
    import requests
except ImportError:
    print("[!] Installing requests library...")
    os.system(f"{sys.executable} -m pip install requests")
    import requests

# ============================================================
# Configuration
# ============================================================

OPENROUTER_API_KEY = "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"
MODEL = "anthropic/claude-sonnet-4"  # Claude 4.6 (1M Context) via OpenRouter
OPENROUTER_URL = "https://openrouter.ai/api/v1/chat/completions"

# Project root (relative to this script)
PROJECT_ROOT = Path(__file__).parent.parent

# Files to analyze (high-risk attack surface)
TARGET_FILES = {
    "Frontend API Routes": [
        "frontend/src/app/api/apy/route.ts",
        "frontend/src/app/api/stats/route.ts",
    ],
    "Frontend Pages (XSS surface)": [
        "frontend/src/app/page.tsx",
        "frontend/src/app/terminal/page.tsx",
        "frontend/src/components/KerneLive.tsx",
    ],
    "Frontend Configuration": [
        "frontend/src/config.ts",
        "frontend/next.config.ts",
    ],
    "Smart Contracts (Core Vault)": [
        "src/KerneVault.sol",
        "src/InsuranceFund.sol",
        "src/KerneTreasury.sol",
    ],
    "Smart Contracts (Tokens)": [
        "src/KUSD.sol",
        "src/KerneToken.sol",
        "src/KerneStaking.sol",
    ],
    "Smart Contracts (ZIN)": [
        "src/ZINPool.sol",
        "src/ZINExecutor.sol",
    ],
    "Bot (Hedging Engine)": [
        "bot/engine.py",
        "bot/exchange_manager.py",
        "bot/chain_manager.py",
        "bot/api_connector.py",
    ],
    "Bot (Security Critical)": [
        "bot/panic.py",
        "bot/sentinel_monitor.py",
        "bot/mev_protection.py",
    ],
}

# Vulnerability categories to test
VULN_CATEGORIES = [
    {
        "name": "Injection Vulnerabilities",
        "description": "SQL injection, NoSQL injection, command injection, SSRF via user-controlled inputs in API routes and data fetching logic",
        "owasp": "A03:2021 - Injection",
    },
    {
        "name": "Cross-Site Scripting (XSS)",
        "description": "Reflected XSS, stored XSS, DOM-based XSS in React components, especially user inputs on terminal page and dynamic content rendering",
        "owasp": "A07:2021 - Cross-Site Scripting",
    },
    {
        "name": "Broken Authentication & Authorization",
        "description": "Wallet-gated feature bypasses, missing access control on API routes, privilege escalation in smart contract roles (STRATEGIST_ROLE, PAUSER_ROLE)",
        "owasp": "A01:2021 - Broken Access Control",
    },
    {
        "name": "Smart Contract Vulnerabilities",
        "description": "Reentrancy attacks, integer overflow/underflow, flash loan exploits, oracle manipulation, front-running, access control bypasses, storage collision",
        "owasp": "Smart Contract Security",
    },
    {
        "name": "Server-Side Request Forgery (SSRF)",
        "description": "API routes that fetch external data (yield APIs, on-chain data) that could be manipulated to access internal resources",
        "owasp": "A10:2021 - SSRF",
    },
    {
        "name": "Sensitive Data Exposure",
        "description": "API keys, private keys, wallet addresses, or configuration secrets exposed in frontend code, environment variables leaked to client",
        "owasp": "A02:2021 - Cryptographic Failures",
    },
]


def read_file_safe(filepath: str) -> str:
    """Read a file, return contents or error message."""
    full_path = PROJECT_ROOT / filepath
    try:
        if full_path.exists():
            content = full_path.read_text(encoding="utf-8", errors="replace")
            # Truncate very large files (high limit â€” leveraging 1M context window)
            if len(content) > 100000:
                content = content[:100000] + "\n\n... [TRUNCATED - file too large] ..."
            return content
        else:
            return f"[FILE NOT FOUND: {filepath}]"
    except Exception as e:
        return f"[ERROR READING {filepath}: {e}]"


def find_solidity_files() -> list:
    """Find all .sol files in src/ directory."""
    sol_files = []
    src_dir = PROJECT_ROOT / "src"
    if src_dir.exists():
        for f in src_dir.rglob("*.sol"):
            rel = f.relative_to(PROJECT_ROOT)
            sol_files.append(str(rel).replace("\\", "/"))
    return sol_files


def call_gemini(system_prompt: str, user_prompt: str, max_tokens: int = 16000) -> str:
    """Call Claude 4.6 (1M Context) via OpenRouter API."""
    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "Content-Type": "application/json",
        "HTTP-Referer": "https://kerne.ai",
        "X-Title": "Kerne Protocol Security Audit",
    }
    
    payload = {
        "model": MODEL,
        "messages": [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt},
        ],
        "max_tokens": max_tokens,
        "temperature": 0.05,  # Very low temperature for precise security analysis
    }
    
    try:
        response = requests.post(OPENROUTER_URL, headers=headers, json=payload, timeout=600)
        response.raise_for_status()
        data = response.json()
        return data["choices"][0]["message"]["content"]
    except requests.exceptions.Timeout:
        return "[ERROR: API request timed out after 600 seconds]"
    except requests.exceptions.HTTPError as e:
        return f"[ERROR: HTTP {e.response.status_code} - {e.response.text[:500]}]"
    except Exception as e:
        return f"[ERROR: {str(e)}]"


def run_reconnaissance(all_code: dict) -> str:
    """Phase 1: Reconnaissance - Map the attack surface."""
    print("\n" + "=" * 60)
    print("  PHASE 1: RECONNAISSANCE")
    print("=" * 60)
    
    system_prompt = """You are an expert penetration tester performing a white-box security assessment of a DeFi protocol called Kerne Protocol. 

Kerne Protocol is a delta-neutral yield infrastructure built on Base (Ethereum L2). It features:
- ERC-4626 vaults that accept ETH deposits
- A hedging engine that shorts ETH on Hyperliquid to achieve delta neutrality
- Cross-chain expansion via LayerZero V2 OFT tokens
- A Next.js frontend with API routes
- Smart contracts in Solidity 0.8.24

Your task is to perform RECONNAISSANCE: map the complete attack surface of this application. Identify all entry points, data flows, trust boundaries, and potential attack vectors."""

    # Build code summary
    code_summary = ""
    for category, files in all_code.items():
        code_summary += f"\n\n### {category}\n"
        for filepath, content in files.items():
            if "[FILE NOT FOUND" not in content and "[ERROR" not in content:
                code_summary += f"\n**{filepath}** ({len(content)} chars):\n```\n{content[:5000]}\n```\n"
    
    user_prompt = f"""Analyze the following source code and produce a detailed reconnaissance report:

{code_summary}

Produce a structured report with:
1. **Attack Surface Map** - All entry points (API routes, contract functions, user inputs)
2. **Data Flow Analysis** - How data moves through the system (frontend â†’ API â†’ blockchain)
3. **Trust Boundaries** - Where trust transitions occur (user â†’ frontend â†’ contract â†’ CEX)
4. **Technology Stack Fingerprint** - Frameworks, libraries, versions, known CVEs
5. **Authentication & Authorization Model** - How access control works
6. **High-Risk Areas** - Top 10 areas most likely to contain vulnerabilities"""

    result = call_gemini(system_prompt, user_prompt, max_tokens=32000)
    print("  âœ“ Reconnaissance complete")
    return result


def run_deep_code_review(all_code: dict, recon_report: str) -> str:
    """Phase 1.5: Deep code review â€” line-by-line analysis of critical files."""
    print("\n" + "=" * 60)
    print("  PHASE 1.5: DEEP CODE REVIEW (Critical Files)")
    print("=" * 60)
    
    system_prompt = """You are a world-class smart contract auditor and application security expert performing a deep code review. You have audited protocols managing billions in TVL.

Analyze every line of the provided smart contract code for:
1. Reentrancy vulnerabilities (even with ReentrancyGuard â€” check for cross-function reentrancy)
2. Access control gaps (missing modifiers, inconsistent role checks)
3. Integer arithmetic issues (even with Solidity 0.8.24 â€” check for precision loss, rounding errors)
4. Flash loan attack vectors (price manipulation, sandwich attacks)
5. Cross-contract interaction risks (low-level calls, delegate calls, callback patterns)
6. Storage layout issues (slot collisions in upgradeable patterns)
7. Gas griefing and DoS vectors
8. Front-running opportunities
9. Oracle manipulation paths
10. Economic exploits (MEV, arbitrage against the protocol)

Be extremely thorough. This is a DeFi protocol handling real money. Every missed vulnerability is a potential loss of funds."""

    # Focus on the most critical contracts
    critical_files = {}
    critical_names = ["KerneVault.sol", "kUSDMinter.sol", "KUSDPSM.sol", "KerneArbExecutor.sol", 
                      "KerneFlashArbBot.sol", "KerneInsuranceFund.sol", "KerneIntentExecutorV2.sol"]
    
    for category, files in all_code.items():
        for filepath, content in files.items():
            basename = os.path.basename(filepath)
            if basename in critical_names:
                critical_files[filepath] = content
    
    if not critical_files:
        # Fallback: use all Solidity files
        for category, files in all_code.items():
            for filepath, content in files.items():
                if filepath.endswith(".sol") and "mock" not in filepath.lower():
                    critical_files[filepath] = content
    
    code_block = ""
    for filepath, content in critical_files.items():
        code_block += f"\n\n**{filepath}**:\n```solidity\n{content}\n```\n"
    
    user_prompt = f"""## Reconnaissance Context
{recon_report[:6000]}

## Critical Smart Contracts to Review
{code_block}

## Instructions
Perform a line-by-line security audit of these contracts. For each vulnerability found:

1. **Severity**: CRITICAL / HIGH / MEDIUM / LOW / INFORMATIONAL
2. **Title**: Descriptive name
3. **File:Line**: Exact location
4. **Root Cause**: Why the vulnerability exists
5. **Impact**: What an attacker can achieve
6. **Exploit Path**: Step-by-step attack scenario with specific function calls
7. **Proof of Concept**: Solidity test or transaction sequence
8. **Fix**: Specific code change needed

Also identify:
- **Gas optimization opportunities** that could reduce user costs
- **Code quality issues** that increase audit risk
- **Architectural concerns** that could become vulnerabilities at scale"""

    result = call_gemini(system_prompt, user_prompt, max_tokens=32000)
    print("  âœ“ Deep code review complete")
    return result


def run_economic_attack_analysis(all_code: dict, recon_report: str) -> str:
    """Phase 2.5: Economic attack analysis â€” DeFi-specific exploit vectors."""
    print("\n" + "=" * 60)
    print("  PHASE 2.5: ECONOMIC ATTACK ANALYSIS")
    print("=" * 60)
    
    system_prompt = """You are a DeFi security researcher specializing in economic attacks and game-theoretic exploits. You have discovered exploits in protocols like Euler, Mango Markets, and Cream Finance.

Analyze the Kerne Protocol for economic attack vectors:
1. **Flash Loan Attacks**: Can an attacker manipulate prices, collateral ratios, or share prices within a single transaction?
2. **Sandwich Attacks**: Can MEV bots front-run/back-run user deposits, withdrawals, or swaps?
3. **Oracle Manipulation**: Can the off-chain asset reporting be exploited? Can the yield oracle be gamed?
4. **Governance Attacks**: Can role holders (STRATEGIST, SOLVER, ADMIN) extract value beyond their intended permissions?
5. **Liquidity Attacks**: Can an attacker drain the vault's liquid buffer to prevent withdrawals?
6. **Cross-Chain Attacks**: Can LayerZero OFT bridging be exploited for double-spending or message replay?
7. **Insurance Fund Attacks**: Can the insurance fund be drained or manipulated?
8. **Tokenomics Exploits**: Can the KERNE token staking or airdrop mechanisms be gamed?
9. **Delta-Neutral Strategy Risks**: What happens if the hedging engine fails? Can this be triggered intentionally?
10. **Composability Risks**: How do interactions between KerneVault, kUSDMinter, KUSDPSM, and the Insurance Fund create attack surfaces?

For each attack vector, provide:
- Feasibility assessment (Easy/Medium/Hard/Theoretical)
- Expected profit for attacker
- Required capital
- Detection difficulty"""

    code_block = ""
    for category, files in all_code.items():
        for filepath, content in files.items():
            if "[FILE NOT FOUND" not in content and "[ERROR" not in content:
                code_block += f"\n\n**{filepath}**:\n```\n{content[:8000]}\n```\n"
    
    user_prompt = f"""## Reconnaissance Context
{recon_report[:6000]}

## Source Code
{code_block}

## Task
Perform a comprehensive economic attack analysis of Kerne Protocol. Think like a sophisticated attacker with unlimited capital and technical expertise. Identify every possible way to extract value from the protocol beyond intended yields."""

    result = call_gemini(system_prompt, user_prompt, max_tokens=32000)
    print("  âœ“ Economic attack analysis complete")
    return result


def run_vulnerability_analysis(all_code: dict, recon_report: str, vuln_category: dict) -> str:
    """Phase 2: Vulnerability Analysis for a specific category."""
    print(f"  â†’ Analyzing: {vuln_category['name']}...")
    
    system_prompt = f"""You are an expert penetration tester specializing in {vuln_category['name']} ({vuln_category['owasp']}).

You are performing a white-box security assessment of Kerne Protocol, a DeFi protocol with:
- Next.js frontend with API routes on Vercel
- Solidity 0.8.24 smart contracts on Base (ERC-4626 vaults)
- Python hedging bot connecting to Hyperliquid CEX
- LayerZero V2 cross-chain token bridges

Your task is to find REAL, EXPLOITABLE vulnerabilities in the category: {vuln_category['name']}.
Focus on: {vuln_category['description']}

CRITICAL RULES:
- Only report vulnerabilities you can prove with specific code references
- Include the exact file, line, and function where the vulnerability exists
- Provide a concrete exploit scenario (step-by-step)
- Rate severity: CRITICAL / HIGH / MEDIUM / LOW
- If no vulnerabilities found in this category, say so explicitly"""

    # Build relevant code
    code_block = ""
    for category, files in all_code.items():
        for filepath, content in files.items():
            if "[FILE NOT FOUND" not in content and "[ERROR" not in content:
                code_block += f"\n\n**{filepath}**:\n```\n{content}\n```\n"
    
    user_prompt = f"""## Reconnaissance Context
{recon_report[:4000]}

## Source Code to Analyze
{code_block}

## Task
Find all {vuln_category['name']} vulnerabilities in the code above. For each finding:

1. **Title** - Short descriptive name
2. **Severity** - CRITICAL / HIGH / MEDIUM / LOW
3. **Location** - Exact file and function
4. **Description** - What the vulnerability is
5. **Exploit Scenario** - Step-by-step how an attacker would exploit it
6. **Proof of Concept** - Code/commands to reproduce
7. **Remediation** - How to fix it

If no vulnerabilities found, explain why the code is secure against this category."""

    result = call_gemini(system_prompt, user_prompt, max_tokens=16000)
    return result


def generate_final_report(recon: str, findings: dict) -> str:
    """Phase 3: Generate the final pentest report."""
    print("\n" + "=" * 60)
    print("  PHASE 3: REPORT GENERATION")
    print("=" * 60)
    
    system_prompt = """You are a senior penetration testing report writer. Compile the findings from multiple vulnerability analysis phases into a single, professional penetration testing report.

Format the report in Markdown with:
- Executive Summary (2-3 paragraphs for non-technical stakeholders)
- Findings Summary Table (severity, category, title)
- Detailed Findings (each with full exploit details)
- Remediation Priority Matrix
- Overall Security Posture Assessment"""

    findings_text = ""
    for category, result in findings.items():
        findings_text += f"\n\n## {category}\n{result}\n"
    
    user_prompt = f"""## Reconnaissance Report
{recon[:3000]}

## Vulnerability Analysis Results
{findings_text}

## Instructions
Compile these findings into a professional penetration testing report for Kerne Protocol. 
- Remove any false positives or speculative findings
- Prioritize by severity and exploitability
- Include an overall security score (0-100)
- Date: {datetime.now().strftime('%Y-%m-%d')}
- Tester: Shannon AI (Claude 4.6 â€” 1M Context) via Kerne Security Pipeline"""

    result = call_gemini(system_prompt, user_prompt, max_tokens=32000)
    print("  âœ“ Report generated")
    return result


def main():
    print("""
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘         KERNE PROTOCOL â€” AI PENETRATION TEST            â•‘
    â•‘         Model: Claude 4.6 (1M Context) via OpenRouter   â•‘
    â•‘         Mode: Deep White-Box Security Audit              â•‘
    â•‘         Budget: $20-30 (Comprehensive)                   â•‘
    â•‘         Duration: ~10-20 minutes                         â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # â”€â”€ Phase 0: Collect Source Code â”€â”€
    print("=" * 60)
    print("  PHASE 0: COLLECTING SOURCE CODE")
    print("=" * 60)
    
    # Auto-discover Solidity files
    sol_files = find_solidity_files()
    if sol_files:
        # Add discovered files to smart contract categories
        for sol_file in sol_files:
            basename = os.path.basename(sol_file)
            # Check if already in target files
            already_listed = any(
                sol_file in files 
                for files in TARGET_FILES.values()
            )
            if not already_listed:
                if "interface" in sol_file.lower() or "I" == basename[0]:
                    continue  # Skip interfaces
                if "test" in sol_file.lower():
                    continue  # Skip test files
                TARGET_FILES.setdefault("Smart Contracts (Auto-discovered)", []).append(sol_file)
    
    all_code = {}
    total_files = 0
    for category, filepaths in TARGET_FILES.items():
        all_code[category] = {}
        for fp in filepaths:
            content = read_file_safe(fp)
            if "[FILE NOT FOUND" not in content:
                all_code[category][fp] = content
                total_files += 1
                print(f"  âœ“ {fp}")
            else:
                print(f"  âœ— {fp} (not found)")
    
    print(f"\n  Collected {total_files} files for analysis\n")
    
    if total_files == 0:
        print("[ERROR] No source files found. Make sure you're running from the kerne-main root directory.")
        sys.exit(1)
    
    # â”€â”€ Phase 1: Reconnaissance â”€â”€
    recon = run_reconnaissance(all_code)
    
    # â”€â”€ Phase 1.5: Deep Code Review â”€â”€
    deep_review = run_deep_code_review(all_code, recon)
    
    # â”€â”€ Phase 2: Vulnerability Analysis â”€â”€
    print("\n" + "=" * 60)
    print("  PHASE 2: VULNERABILITY ANALYSIS (6 OWASP Categories)")
    print("=" * 60)
    
    findings = {}
    for vuln_cat in VULN_CATEGORIES:
        result = run_vulnerability_analysis(all_code, recon, vuln_cat)
        findings[vuln_cat["name"]] = result
    
    print("  âœ“ All vulnerability categories analyzed")
    
    # â”€â”€ Phase 2.5: Economic Attack Analysis â”€â”€
    economic_analysis = run_economic_attack_analysis(all_code, recon)
    
    # â”€â”€ Phase 3: Report Generation â”€â”€
    # Include deep review and economic analysis in findings
    findings["Deep Code Review"] = deep_review
    findings["Economic Attack Analysis"] = economic_analysis
    
    final_report = generate_final_report(recon, findings)
    
    # â”€â”€ Save Report â”€â”€
    report_dir = Path(__file__).parent / "reports"
    report_dir.mkdir(exist_ok=True)
    
    report_path = report_dir / f"kerne_pentest_{timestamp}.md"
    
    full_report = f"""# Kerne Protocol â€” Penetration Test Report
**Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Model:** Claude 4.6 (1M Context) via OpenRouter
**Mode:** Deep White-Box Security Audit (Comprehensive â€” $20-30 Budget)
**Files Analyzed:** {total_files}

---

## Reconnaissance Report

{recon}

---

## Vulnerability Analysis

"""
    for category, result in findings.items():
        full_report += f"\n### {category}\n\n{result}\n\n---\n"
    
    full_report += f"\n## Final Report\n\n{final_report}\n"
    
    report_path.write_text(full_report, encoding="utf-8")
    
    print("\n" + "=" * 60)
    print("  PENTEST COMPLETE")
    print("=" * 60)
    print(f"\n  ğŸ“„ Report saved to: {report_path}")
    print(f"  ğŸ“Š Files analyzed: {total_files}")
    print(f"  ğŸ” Categories tested: {len(VULN_CATEGORIES)} + Deep Review + Economic Analysis")
    print()


if __name__ == "__main__":
    main()