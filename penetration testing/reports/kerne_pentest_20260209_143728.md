# Kerne Protocol — Penetration Test Report
**Date:** 2026-02-09 14:58:25
**Model:** ChatGPT 5.2 (via OpenRouter)
**Mode:** Deep White-Box Security Audit
**Files Analyzed:** 52

---

## Reconnaissance Report

## 1) Attack Surface Map (Entry Points)

### A. Public Web / Frontend (Browser-facing)
**Pages / components that render dynamic data**
- `frontend/src/app/page.tsx` (Landing)
  - Client-side `fetch('https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT')`
  - Renders price-derived values in the DOM (React state → JSX)
  - XSS surface primarily through any future interpolation of untrusted strings (currently mostly numeric).
- `frontend/src/app/terminal/page.tsx` (Terminal)
  - Calls internal API routes:
    - `GET /api/apy`
    - `GET /api/solvency` (not shown, but referenced)
    - `GET /api/eth-history` (not shown, but referenced)
  - Fallback data generation logic (no obvious injection, but can mask real failures and complicate monitoring).
- `frontend/src/components/KerneLive.tsx`
  - Pure client-side state changes (no external inputs other than randomness). Low direct security impact.

**Wallet / chain interaction (implicit attack surface)**
- `wagmi` usage (`useAccount`) implies typical wallet-connect flows and signing prompts. Any transaction-building components (e.g., `VaultInteraction`) are critical UI-to-chain surfaces (not included here, but referenced).

---

### B. Next.js API Routes (Server-side entry points)
These are **unauthenticated** endpoints by default unless protected by middleware (none shown).

#### 1. `GET /api/stats` — `frontend/src/app/api/stats/route.ts`
- **Inputs**
  - No query params; relies on environment variables.
- **Outbound dependencies**
  - `process.env.RPC_URL` (Base RPC): used by `viem` `createPublicClient()`
  - `VAULT_ADDRESS` (from `NEXT_PUBLIC_VAULT_ADDRESS` or fallback hardcoded)
  - Binance price API: `https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT`
- **Attack vectors**
  - **DoS / resource exhaustion**: each request does on-chain read + external fetch; no caching/rate limit.
  - **RPC trust**: a malicious/compromised RPC can return manipulated `totalAssets()` results.
  - **Data integrity**: relies on Binance price JSON without validation; could output `NaN` / weird formatting.

#### 2. `GET /api/apy` — `frontend/src/app/api/apy/route.ts`
- **Inputs**
  - Likely query param `symbol` (function supports `symbol`, validation present). Full route handler not shown, but fetchers do validate.
- **Outbound dependencies**
  - Hyperliquid info endpoint (POST): `https://api.hyperliquid.xyz/info`
  - Binance funding endpoint: `https://fapi.binance.com/fapi/v1/fundingRate?...`
  - Bybit tickers endpoint: `https://api.bybit.com/v5/market/tickers?...`
- **Controls**
  - `validateSymbol()` allowlist: `ETH/BTC/SOL/ARB/OP`, strips non-alphanumerics.
  - AbortSignal timeout (10s) on some requests.
- **Attack vectors**
  - **DoS** via repeated calls causing outbound HTTP fanout.
  - **Integrity risk**: public APIs are unauthenticated; attacker can’t directly change responses, but upstream outages/poisoning affect displayed APY.
  - **Logic fragility**: silent catches hide errors → monitoring blind spots.
  - **SSRF**: largely mitigated by fixed hostnames + symbol allowlist.

> **Not shown but referenced:** `/api/solvency`, `/api/eth-history` are additional entry points; treat as unknown-high until reviewed.

---

### C. Smart Contracts (On-chain entry points)
Below is the **external/public callable surface** and “privileged surfaces” (roles/owner). Many files are truncated; where functions are not visible, the report flags “expected”.

#### 1. `KerneVault` (ERC-4626 + AccessControl + Pausable + Flash Lender)
- **User-callable (expected ERC-4626)**
  - `deposit`, `mint`, `withdraw`, `redeem` (standard ERC4626)
  - `totalAssets` (view; critical because it incorporates off-chain notions)
- **Privileged / sensitive (inferred from state + typical pattern)**
  - `initialize(...)` (factory clones call this; seen in `KerneVaultFactory`)
  - `pause()/unpause()` (Pausable + panic script calls `pause()`)
  - Functions to update:
    - `offChainAssets`, `l1Assets`, `hedgingReserve`, `verificationNode`, `insuranceFund`, fee parameters, whitelist settings, etc.
- **Flashloan surface**
  - Implements `IERC3156FlashLender`: `flashLoan`, `flashFee`, `maxFlashLoan` (expected)
- **Key attack vectors**
  - **Hybrid accounting manipulation** (offChainAssets/l1Assets/shadowYield/verification)
  - **Flashloan abuse** if fee/allowlist assumptions wrong
  - **Role compromise** (STRATEGIST_ROLE/PAUSER_ROLE/admin)

#### 2. `kUSDMinter`
- **User-callable**
  - Mint/burn flows (functions not shown but implied by events and mappings):
    - `mint` / `burn` operations against `kLP` collateral
    - Liquidation functions (implied by constants + `Liquidated` event)
  - Leverage/folding via flash loans (`IERC3156FlashBorrower`)
- **Privileged**
  - `MANAGER_ROLE` (parameter changes, aggregator updates, oracle address changes)
- **External dependency surface**
  - `dexAggregator` address and `aggregatorData` (likely arbitrary calldata execution)
  - `yieldOracle.getTWAY(vault)` (oracle trust)
- **Attack vectors**
  - **Arbitrary call/call-data injection** into aggregator (classic high risk)
  - **Oracle manipulation / staleness** impacting collateral ratios and liquidation
  - **Flashloan callback correctness** (repayment invariants)

#### 3. `KUSDPSM` (Peg Stability Module + flash lender)
- **User-callable**
  - Swaps between kUSD and supported stables (swap function not shown but implied)
  - Flash loans (`IERC3156FlashLender`)
- **Privileged**
  - `MANAGER_ROLE`, `ARBITRAGEUR_ROLE`
  - Configure: supported stables, fees, oracle addresses, caps, insurance draw limits
- **Attack vectors**
  - **Oracle trust boundary**: `oracles[stable]` (Chainlink-like) can be misconfigured
  - **Cap/exposure accounting bugs**
  - **Flashloan + swap combo** reentrancy/price manipulation if safeguards incomplete

#### 4. LayerZero OFT / OApp Components
- `KerneOFT` (v1), `KerneOFTV2` (v2), `KerneArbSettler`, `KerneVerificationNode` (OApp)
- **Entry points**
  - OFT send/receive hooks (LayerZero endpoints)
  - `KerneArbSettler.settle(...)` sends cross-chain
  - `KerneVerificationNode.submitVerifiedAttestation(...)` accepts signed data
- **Attack vectors**
  - **Cross-chain message spoofing / endpoint misconfig**
  - **Delegate/owner key compromise** → mint/burn authority on OFTs
  - **Replay / signature threshold weaknesses** in `KerneVerificationNode` (threshold default `1`)

#### 5. Arbitrage / Solver / Intent execution contracts
- `KerneArbExecutor`, `KerneFlashArbBot`, `KerneLSTSolver`, `KerneIntentExecutor`, `KerneIntentExecutorV2`, `KerneZINPool`, `KerneZINRouter`, `KerneDexAdapter`
- **Entry points**
  - “Execute” functions that perform external calls to routers/aggregators
  - Flashloan callbacks `onFlashLoan(...)`
  - Allowlists/whitelists for targets (present in `KerneArbExecutor`; others unknown)
- **Attack vectors**
  - **Arbitrary external call execution** (target + calldata)
  - **Router trust & approval management** (token approvals, forceApprove patterns)
  - **MEV + sandwich** risk (some private submission exists off-chain, but on-chain calls still exposed)

#### 6. Token and funds management contracts
- `kUSD` (mint role), `KerneToken` (mint role exists but not granted in constructor), `KerneStaking`, `KerneTreasury`, `KerneInsuranceFund`, `KerneEcosystemFund`, `KerneAirdrop`, `KerneYieldStripper`, `skUSD`
- **Entry points**
  - Minting (`kUSD.mint` role gated)
  - Treasury swaps/buybacks (Aerodrome router)
  - Insurance claims (`claim`) role gated
  - Airdrop claim paths (Merkle proof + claim type logic; functions not shown)
- **Attack vectors**
  - **Role/owner compromise**
  - **Merkle claim edge cases** (double-claim, incorrect accounting, griefing)
  - **Token approval/transfer assumptions** (non-standard ERC20s)

#### 7. Factory/Registry
- `KerneVaultFactory.deployVault(...)` (payable)
- `KerneVaultRegistry.registerVault(...)`
- **Attack vectors**
  - **Clone initialization bugs** (uninitialized clone takeover)
  - **Fee transfer via `.call{value:...}`** (reentrancy not likely but still a surface)
  - **Registry poisoning** mitigated by `authorizedRegistrars`, but owner compromise is critical

---

### D. Off-chain Bot / Operations Surfaces (Highly privileged)
These are not “public endpoints” but are major compromise targets.

- `bot/chain_manager.py`
  - Loads `PRIVATE_KEY`, `RPC_URL`, `VAULT_ADDRESS`, other contract addresses
  - Signs and sends transactions → **private key is a primary crown jewel**
- `bot/engine.py` / `exchange_manager.py`
  - Places shorts and manages leverage across exchanges (Hyperliquid primary, others optional)
  - Any API keys / credentials are sensitive (env-var driven)
- `bot/panic.py`
  - Can pause the vault on demand using `PRIVATE_KEY`
- `bot/sentinel_monitor.py`
  - Automated monitoring + potential automated reactions (flash rebalances)
- `bot/mev_protection.py`
  - Submits signed transactions to “private endpoints”; misconfiguration can leak txs or fail-open to public mempool

---

## 2) Data Flow Analysis (Frontend → API → Chain → CEX)

### Flow 1: TVL/Stats shown in UI
1. Browser requests `GET /api/stats`
2. Next.js server:
   - Reads `RPC_URL` → calls Base RPC via `viem`
   - Reads `KerneVault.totalAssets()` at `VAULT_ADDRESS`
   - Fetches ETH price from Binance spot API
   - Computes `tvl_usd`, returns JSON
3. Browser renders stats

**Integrity dependencies**
- RPC response correctness (Base RPC)
- Vault `totalAssets()` correctness (hybrid accounting)
- Binance price correctness

---

### Flow 2: APY display
1. Browser requests `GET /api/apy` (Terminal) or client fetches Binance directly (Landing)
2. Next.js server calls:
   - Hyperliquid funding
   - Binance funding
   - Bybit funding
   - (Also mentions LST yields in header comment; not shown in excerpt)
3. Response is rendered in UI

**Key recon note:** the APY is computed off-chain using public APIs; it is *display-grade*, not trustless.

---

### Flow 3: User deposits/withdraws (expected)
1. User connects wallet (wagmi)
2. UI builds ERC-4626 calls to `KerneVault`:
   - deposit ETH/WETH (depending on implementation)
   - receive vault shares (`kLP`)
3. Bot observes events (implied by event-driven queue in `engine.py`) and adjusts hedge on Hyperliquid/CEX.

**Critical dependency:** correctness and security of the event ingestion pipeline (not shown), and bot key custody.

---

### Flow 4: kUSD minting / leverage loop (expected)
1. User supplies `kLP` collateral to `kUSDMinter`
2. Minter may:
   - mint kUSD
   - perform “folding” using flash loans (Vault/PSM as lender)
   - swap via `dexAggregator` (external routers)
3. Position recorded in `positions[user]`

**Highest-risk junction:** minter executing aggregator calldata + relying on oracle-based health factors.

---

### Flow 5: Cross-chain settlement & omnichain assets
1. Profits accumulate on Arbitrum (`KerneArbSettler.pendingProfits`)
2. `settle()` sends OFT message to Base Treasury using LayerZero V2
3. Base receives bridged kUSD (or OFT representation)

**Key dependency:** LayerZero endpoint configuration + delegate/owner keys of OFT/OApp contracts.

---

## 3) Trust Boundaries (Where trust transitions occur)

### Boundary A: User Browser → Next.js Server
- **Unauthenticated** API routes (`/api/apy`, `/api/stats`, and referenced endpoints)
- Risks: abuse for DoS, scraping, forced outbound traffic, log pollution

### Boundary B: Next.js Server → Third-party Public APIs
- Hyperliquid/Binance/Bybit endpoints are untrusted inputs
- Risks: manipulated/erroneous data, downtime, rate limiting, returning unexpected JSON types

### Boundary C: Next.js Server → Base RPC Provider
- RPC is a strong trust dependency; can lie about chain state if malicious
- This influences displayed TVL and any server-side decisions (none shown beyond display)

### Boundary D: On-chain Contracts → Privileged Operators (Roles/Owners)
- AccessControl roles gate powerful state transitions:
  - strategist updates, pausing, minting, insurance claims, oracle updates
- Risks: key compromise, misconfigured multisig, role misassignment, uninitialized clones

### Boundary E: On-chain System → Cross-chain Messaging (LayerZero)
- Trust boundary at endpoint/validator layer + config
- Risks: wrong endpoint, delegate compromise, message replay/compose edge cases

### Boundary F: Protocol → CEX/Hyperliquid (Off-chain custody and hedging)
- Largest economic trust boundary:
  - Funds in custody (`offChainAssets`) are not enforceable on-chain
  - Hedge state correctness is off-chain and reported back (attestations)
- Risks: CEX account compromise, API key leak, withdrawal address tampering, insolvency, incorrect reporting

### Boundary G: Bot Infrastructure → Blockchain
- Bot private key signs transactions (pause, rebalance, updates)
- Risks: server compromise, CI/CD secret leakage, dependency supply-chain, logging sensitive data

---

## 4) Technology Stack Fingerprint (Frameworks/Libraries/Versions/Advisory Targets)

### Frontend / Server
- **Next.js App Router** (`src/app/.../route.ts`, `page.tsx`)
  - Version not provided (must be extracted from `package.json`)
  - Recon action: check for known Next.js SSRF/cache poisoning, middleware bypass, and request smuggling advisories relevant to deployed version.
- **React** (client components)
- **viem** + `viem/chains` (Base)
- **wagmi** (wallet connection)
- **framer-motion**, **lucide-react**

**Security-relevant observations**
- No `next.config.ts` hardening shown (CSP headers, `poweredByHeader: false`, image domains, etc.).
- API routes have no auth, no rate limiting, no caching.

### Smart Contracts
- Solidity `0.8.24` (vault, many modules), some `^0.8.20`
- OpenZeppelin:
  - `ERC4626`, `AccessControl`, `Ownable`, `ReentrancyGuard`, `Pausable`, `SafeERC20`, `ERC20Votes`, `ERC20Permit`
  - Version not pinned in excerpt; must confirm in `package.json`/`foundry.toml`.
- LayerZero:
  - OFT v1 (`oft-evm/v1/OFT.sol`)
  - OFT v2 (`oft-evm/v2/OFT.sol`)
  - OApp (`oapp-evm`)
- Flash loans: `IERC3156FlashLender/Borrower`

**Security-relevant recon items**
- Mixed LayerZero versions (v1 + v2) increases config complexity and audit surface.
- Many “executor/router” contracts that perform external calls—historically high bug density.

### Bot / Ops
- Python asyncio architecture
- `web3.py`
- `requests` and/or `httpx`
- `loguru`
- `.env` secrets via `python-dotenv`

**Advisory targets**
- Dependency review for `web3.py`, `requests`, `httpx`, and any exchange SDKs used.
- Operational security is as important as code security due to custody and privileged keys.

> CVEs: exact CVE mapping requires precise versions from lockfiles. For recon, prioritize checking:
> - Next.js security advisories for the deployed major/minor
> - OpenZeppelin release notes for the pinned version
> - LayerZero OFT/OApp known issues for the exact commit/tag
> - `web3.py` / `requests` / `httpx` dependency advisories in your SBOM

---

## 5) Authentication & Authorization Model

### A. Web/API Layer
- **No authentication** shown for:
  - `/api/stats`
  - `/api/apy`
- No API keys used for upstream funding endpoints (public endpoints).
- No rate limiting, API tokens, or HMAC signatures evident.

### B. Smart Contracts
Predominantly **role-based access control**:

- **AccessControl roles**
  - `KerneVault`: `STRATEGIST_ROLE`, `PAUSER_ROLE` (+ `DEFAULT_ADMIN_ROLE`)
  - `kUSD`: `MINTER_ROLE`
  - `KerneToken`: `PAUSER_ROLE`, `MINTER_ROLE` (note: MINTER_ROLE not granted in constructor)
  - `KerneStaking`: `DISTRIBUTOR_ROLE`
  - `KUSDPSM`: `MANAGER_ROLE`, `ARBITRAGEUR_ROLE`
  - Executors/Solvers: `SOLVER_ROLE`, `EXECUTOR_ROLE`, `SENTINEL_ROLE`, `MANAGER_ROLE`
  - Oracles/Verification: `UPDATER_ROLE`, `VERIFIER_ROLE`, `AUDITOR_ROLE`

- **Ownable**
  - `KerneTreasury`, `KerneVaultFactory`, `KerneVaultRegistry`, `KerneDexAdapter`, `KerneEcosystemFund`, `KernePrime`, OFT ownership patterns

### C. Off-chain bot authorization
- Authority is possession of:
  - `PRIVATE_KEY` (chain signer)
  - Exchange API keys (optional, env-var)
  - Discord/webhook alerting tokens (implied)

**Recon conclusion:** the protocol’s security posture heavily depends on **key management** for:
- `DEFAULT_ADMIN_ROLE` holders
- `Ownable` owners/delegates
- Bot hot wallet keys
- LayerZero delegate/owner keys

---

## 6) High-Risk Areas (Top 10 likely vulnerability zones)

1. **Hybrid accounting in `KerneVault.totalAssets()`**
   - Anything incorporating `offChainAssets`, `l1Assets`, “shadow yield”, or verification nodes can be manipulated by privileged actors or by compromised reporting pipelines.
   - Impacts share price, solvency, minting ratios, and user trust.

2. **`kUSDMinter` external aggregator execution (`dexAggregator` + calldata)**
   - Historically the #1 source of critical bugs: arbitrary call injection, approval misuse, incorrect min-out checks, and callback reentrancy patterns.

3. **Flash loan surfaces across Vault/PSM/ZINPool + borrower callbacks**
   - `IERC3156` implementations must enforce strict repayment and fee logic.
   - Any missing token allowlists, fee bypass, or callback assumptions become critical.

4. **LayerZero cross-chain messaging (OFT v1 + v2 + OApp)**
   - Endpoint/delegate misconfiguration can be catastrophic.
   - OFT `mint/burn` restricted to owner → owner key compromise = total supply compromise.

5. **`KerneVerificationNode` attestation security**
   - Default `threshold = 1` is a red flag: single signer compromise can forge “proof of reserve”.
   - Replay protection, signer set management, and signature counting must be validated end-to-end.

6. **PSM oracle configuration (`oracles[stable]`) and depeg logic**
   - Wrong oracle address, stale rounds, decimals mismatch, or missing heartbeat checks can lead to incorrect pricing and draining swaps/flash loans.

7. **Factory clone initialization / upgrade hygiene**
   - `KerneVaultFactory` clones `implementation` and calls `initialize(...)`.
   - If any clone can be left uninitialized (or initialize lacks proper “initializer” guard), it can be seized.

8. **Executor/solver contracts calling external routers**
   - Even with allowlists (`KerneArbExecutor.allowedTargets`), other modules (IntentExecutor/ZINRouter/DexAdapter) may still allow arbitrary calldata to known routers that themselves can trigger complex behaviors.

9. **Operational key custody for bot infrastructure**
   - `bot/chain_manager.py` and `bot/panic.py` rely on a hot `PRIVATE_KEY`.
   - Compromise yields pause control and potentially strategist/admin actions (depending on role assignments).

10. **Unauthenticated Next.js API routes enabling DoS and outbound request amplification**
   - `/api/apy` and `/api/stats` can be hammered to:
     - exhaust server resources
     - trigger outbound rate limits from Binance/Bybit/Hyperliquid
     - degrade UI reliability and monitoring signal (errors swallowed in `/api/apy`)

---

### Suggested next recon steps (to complete the map)
- Collect `package.json`, lockfiles, and deployment configs (Vercel/Node runtime) to pin versions and enumerate concrete CVEs.
- Enumerate **all** Next.js routes (`/api/*`) and all UI transaction components (e.g., `VaultInteraction`) to map every user-driven chain call.
- Extract full ABIs for: `KerneVault`, `kUSDMinter`, `KUSDPSM`, `ZINRouter/ZINPool`, `IntentExecutorV2`, `Treasury` to list every external/public function and role gate.
- Map role holders on deployed contracts (on Base/Arb/OP) to identify real-world blast radius of key compromise.

---

## Vulnerability Analysis


### Injection Vulnerabilities

No **REAL, EXPLOITABLE Injection vulnerabilities** (SQLi / NoSQLi / command injection / SSRF via user-controlled inputs) are present in the code you provided.

Below is a structured justification by attack class, with exact code references (file + function). Since there are **no findings**, there are no exploit steps/PoCs to provide.

---

## 1) SQL Injection — **None Found**

### Why
There is **no SQL/database layer** shown in the provided code:
- No ORM (Prisma/Sequelize/etc.)
- No `pg`, `mysql`, `sqlite`, etc.
- No raw query construction anywhere in the Next.js API routes or the Python bot.

### Code references checked
- `frontend/src/app/api/apy/route.ts` — `GET()`, and all helper fetchers
- `frontend/src/app/api/stats/route.ts` — `GET()`
- `bot/*` — no DB usage visible

---

## 2) NoSQL Injection — **None Found**

### Why
No NoSQL database usage is present (e.g., MongoDB, Redis query construction, Firestore queries, etc.). The only “storage-like” logic shown is in-memory caching and JSON file logging:
- `bot/api_connector.py` — `TTLCache` uses an in-memory dict, not a query language.
- `bot/engine.py` — writes to `buyback_log.json`, but does not interpret attacker-provided selectors/filters.

### Code references checked
- `bot/api_connector.py` — `TTLCache.get()`, `TTLCache.set()`
- `bot/engine.py` — `_ensure_buyback_log()`

---

## 3) Command Injection — **None Found**

### Why
There is no use of OS command execution primitives in the provided code:
- No `child_process.exec/spawn` in Next.js
- No Python `os.system`, `subprocess.*`, `popen`, etc.

### Code references checked
- `frontend/src/app/api/*` (no process execution)
- `bot/*.py` (no subprocess usage)

---

## 4) SSRF / URL Fetch Injection (Next.js API routes) — **None Found**

### A. `/api/apy` is **not SSRFable** with the provided handler
**Location:** `frontend/src/app/api/apy/route.ts` — `export async function GET()`

#### Why
- The handler’s outbound requests go to **hardcoded** third-party hosts only:
  - `https://api.hyperliquid.xyz/info`
  - `https://fapi.binance.com/...`
  - `https://api.bybit.com/...`
  - `https://www.okx.com/...`
  - `https://eth-api.lido.fi/...`
- Although the helper functions accept a `symbol` parameter, the public `GET()` handler **does not read any request query parameter** and invokes them with defaults:
  - `getHyperliquidFunding()`
  - `getBinanceFunding()`
  - `getBybitFunding()`
  - `getOkxFunding()`

So an external attacker cannot influence the request destination/host.

#### Additional hardening present (even if you later add query params)
**Location:** `frontend/src/app/api/apy/route.ts`
- `validateSymbol(symbol: string)` allowlists to: `ETH, BTC, SOL, ARB, OP`
- strips non-alphanumerics and uppercases input

This prevents common SSRF patterns where user input is concatenated into a URL host/path.

---

### B. `/api/stats` is **not SSRFable**
**Location:** `frontend/src/app/api/stats/route.ts` — `export async function GET()`

#### Why
Outbound fetches are fixed:
- `fetch("https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT")`

The only variable external connectivity is the blockchain RPC endpoint:
- `transport: http(process.env.RPC_URL)`

But `process.env.RPC_URL` is **deployment configuration**, not attacker-controlled request input. That is a supply-chain / ops-trust concern, not SSRF via user input.

---

## 5) SSRF / URL Fetch Injection (Frontend) — **None Found (browser-side)**
**Location:** `frontend/src/app/page.tsx` — inside `useEffect()`

Browser-side fetch:
- `fetch('https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT')`

Even if an attacker tricks a user into loading the page, they cannot change the destination; it’s hardcoded.

---

# Summary
### Injection category result: **No vulnerabilities found**
- No SQL/NoSQL query building exists.
- No command execution exists.
- Server-side fetch targets are hardcoded; no user-controlled URL construction.
- Symbol validation exists and is allowlist-based (good SSRF mitigation), though the handler currently doesn’t even accept a symbol from the request.

---

## If you want me to go further
If you provide the missing API routes (`/api/solvency`, `/api/eth-history`) and any Vercel middleware/auth, I can re-check SSRF/injection across *all* server entry points. Also, if there’s any Next.js route that accepts a `url=...` or `rpc=...` parameter (common), that’s typically where SSRF shows up.

---

### Cross-Site Scripting (XSS)

No real, directly exploitable XSS vulnerabilities are present in the code you provided.

I reviewed the browser-facing React/Next.js pages and the Next.js API routes for the classic XSS primitives (reflection of request data into HTML, stored rendering of untrusted content, DOM sinks like `innerHTML` / `dangerouslySetInnerHTML`, and URL/fragment-driven DOM writes). None are present in the snippets.

Below is the reasoning, mapped to the major XSS classes and **specific code locations**.

---

## ✅ XSS Findings (Reflected / Stored / DOM)
**None found in the provided code.**

---

## Why no XSS is exploitable (with code references)

### 1) No HTML injection sinks in React (no `dangerouslySetInnerHTML`)
**Locations**
- `frontend/src/app/page.tsx` → `LandingPage()` and `CountUp()`
- `frontend/src/app/terminal/page.tsx` → `TerminalPage()`
- `frontend/src/components/KerneLive.tsx` → `KerneLive()`

**What I looked for**
- `dangerouslySetInnerHTML`
- Rendering attacker-controlled strings into attributes like `href`, `src`, `style`
- Rendering attacker-controlled strings into raw HTML contexts

**What the code does instead**
- React JSX interpolation like `{card.value}`, `{frozenApy}`, `{fundingRate}`, etc. React **escapes by default**, so even if a string contains `<img onerror=...>`, it will render as text, not execute.

Example (safe due to React escaping):
- `frontend/src/app/terminal/page.tsx` → `TerminalPage()` renders:
  ```tsx
  <p className="text-xl ...">{card.value}</p>
  ```
Even if `card.value` were attacker-controlled, React escapes it.

---

### 2) The only manual DOM write uses `textContent` (safe)
**Location**
- `frontend/src/app/page.tsx` → `CountUp()` component, `useEffect()` `onUpdate`

**Code**
```ts
nodeRef.current.textContent = prefix + latest.toFixed(decimals) + suffix;
```

**Why this is safe**
- Writing to `textContent` does **not** interpret HTML, so it cannot execute script (unlike `innerHTML`).

---

### 3) API routes return JSON only; no reflection into HTML response
**Locations**
- `frontend/src/app/api/apy/route.ts` → `GET()`
- `frontend/src/app/api/stats/route.ts` → `GET()`

**Why reflected XSS is not present**
- These endpoints return `NextResponse.json(...)`, not HTML.
- There’s no code that takes query params (or request headers) and injects them into an HTML page.

**Important note about `/api/apy`**
- Although helper functions accept a `symbol` argument and `validateSymbol()` throws:
  ```ts
  throw new Error(`Invalid symbol: ${symbol}`);
  ```
  the exported handler is:
  ```ts
  export async function GET() {
    ... getHyperliquidFunding() ...
  }
  ```
  and does **not** read any request parameter at all in the snippet you provided. So there is no reflected input to exploit here.

---

### 4) No stored XSS primitives exist in the provided code
Stored XSS requires:
- a persistence layer (DB, KV, file, chain metadata, logs rendered later), and
- later rendering of that data into the DOM unsafely.

In the provided frontend code:
- there is no user-submitted content saved anywhere
- there are no “message”, “comment”, “profile”, “note”, etc. fields
- there is no rendering of persisted untrusted HTML

So **stored XSS cannot be demonstrated from the provided code**.

---

### 5) No DOM-based XSS via URL / hash / postMessage / localStorage
Common DOM-XSS patterns include:
- `location.search`, `location.hash` parsed and written into DOM
- `document.write`, `innerHTML`, `insertAdjacentHTML`
- unsafe uses of `postMessage` or `eval`

None of those sinks/sources appear in:
- `frontend/src/app/page.tsx`
- `frontend/src/app/terminal/page.tsx`
- `frontend/src/components/KerneLive.tsx`

---

## What *could* become XSS later (not reportable as “real” today, but worth guarding)
These are **not exploitable in the current code**, but are common ways teams accidentally introduce XSS later:

1) If `PillButton({href})` ever receives attacker-controlled `href` and is used with something like `href={"javascript:..."}`
   - **Location:** `frontend/src/app/page.tsx` → `PillButton()`
   - Next.js `Link` generally prevents `javascript:` navigation in modern versions, but you should still validate allowed schemes.

2) If any of the chart components (`PerformanceChart`, `ETHComparisonChart`, etc.) use `dangerouslySetInnerHTML` internally (not provided here)
   - Those components are not included, so I cannot confirm.

---

## Hardening recommendations (defense-in-depth)
Even though I can’t prove an XSS in the shown code, you should still add baseline protections:

1) **Add a strict CSP** (especially important for DeFi frontends):
   - `script-src 'self'` (avoid `'unsafe-inline'`)
   - consider nonces/hashes if you must use inline scripts
   - lock down `connect-src` to required APIs

2) **Sanitize any future rich text / markdown rendering**
   - If you add markdown or “announcements” later, use a sanitizer like DOMPurify and avoid raw HTML.

3) **Validate outbound API data types**
   - Your UI assumes numeric fields. Keep it that way: coerce to `number` and reject/ignore strings from upstream APIs.

4) **Avoid introducing `dangerouslySetInnerHTML`**
   - If absolutely needed, sanitize first and keep it in a single, reviewed component.

---

## Summary
- **Reflected XSS:** Not found (no request input is reflected into HTML; API returns JSON only).
- **Stored XSS:** Not found (no persistence + unsafe rendering path shown).
- **DOM-based XSS:** Not found (no DOM sinks like `innerHTML`; only `textContent` used).

If you share the missing components (`PerformanceChart`, `ETHComparisonChart`, `VaultInteraction`, `Navbar/Footer`) and any API routes not shown (`/api/solvency`, `/api/eth-history`), I can continue the XSS audit and either prove concrete issues or confirm they’re clean as well.

---

### Broken Authentication & Authorization

## 1) Unauthorized Insurance Fund “Loss Socialization” (anyone can force payouts)
**Severity:** CRITICAL  
**Location:** `src/KerneInsuranceFund.sol:76-86`, function `socializeLoss(address vault, uint256 amount)`

### Description
`socializeLoss()` is intended to be callable only by an authorized vault (or authorized actor) to pull insurance coverage.  
However, the authorization check is performed against the **function parameter** `vault`, not against `msg.sender`:

```solidity
require(hasRole(AUTHORIZED_ROLE, vault), "Vault not authorized");
```

This means **any external attacker** can call `socializeLoss()` and pass *any vault address that has `AUTHORIZED_ROLE`*, causing the insurance fund to transfer assets to that vault.

This is a classic broken authorization bug: the contract verifies “someone is authorized” but does not verify that the **caller** is that authorized entity.

### Exploit Scenario (step-by-step)
Assumptions that commonly hold in production:
- The protocol grants `AUTHORIZED_ROLE` to the main `KerneVault` (or some official vault) so it can receive coverage.

Steps:
1. Attacker deposits a small amount into the authorized vault to obtain shares.
2. Attacker calls `KerneInsuranceFund.socializeLoss(vault, amount)` with:
   - `vault` = the authorized vault address (has `AUTHORIZED_ROLE`)
   - `amount` = large value (up to the insurance fund balance)
3. Insurance fund transfers assets to the vault (`safeTransfer(vault, coverAmount)`), increasing vault assets / share price.
4. Attacker redeems their vault shares immediately, capturing a pro-rata share of the insurance payout as profit.

Even if the attacker doesn’t profit directly, they can still grief/manipulate protocol accounting by forcing arbitrary insurance transfers.

### Proof of Concept
Using `cast` (Foundry). Replace placeholders:
- `$INSURANCE` = KerneInsuranceFund address
- `$VAULT` = authorized vault address (must have `AUTHORIZED_ROLE` in insurance fund)
- `$ASSET` = insurance asset ERC20 address
- `$ATTACKER_KEY` = attacker private key

```bash
# 1) Attacker gets shares (example assumes vault asset is ERC20 and vault has deposit)
cast send $ASSET "approve(address,uint256)" $VAULT 1000000000000000000 --private-key $ATTACKER_KEY
cast send $VAULT "deposit(uint256,address)" 1000000000000000000 $(cast wallet address --private-key $ATTACKER_KEY) --private-key $ATTACKER_KEY

# 2) Force insurance payout into the vault (NO AUTH REQUIRED besides passing an authorized vault param)
cast send $INSURANCE "socializeLoss(address,uint256)" $VAULT 1000000000000000000000000 --private-key $ATTACKER_KEY

# 3) Redeem attacker shares to realize profit (method depends on vault interface; ERC4626 redeem shown)
# Example: redeem all shares attacker has
ATT_SHARES=$(cast call $VAULT "balanceOf(address)(uint256)" $(cast wallet address --private-key $ATTACKER_KEY))
cast send $VAULT "redeem(uint256,address,address)" $ATT_SHARES $(cast wallet address --private-key $ATTACKER_KEY) $(cast wallet address --private-key $ATTACKER_KEY) --private-key $ATTACKER_KEY
```

### Remediation
Fix authorization to check the **caller**, not the parameter. Any of the following patterns works:

**Option A (simplest):** restrict to authorized callers:
```solidity
function socializeLoss(address vault, uint256 amount) external nonReentrant onlyRole(AUTHORIZED_ROLE) {
    ...
}
```

**Option B (vault-only pull):** require the vault calls for itself:
```solidity
function socializeLoss(uint256 amount) external nonReentrant onlyRole(AUTHORIZED_ROLE) {
    address vault = msg.sender;
    ...
    IERC20(asset).safeTransfer(vault, coverAmount);
}
```

Also consider adding rate limits / per-vault limits similar to your PSM draw-limits.


---

## 2) KerneVault can be initialized/re-initialized by ANYONE (role takeover)
**Severity:** CRITICAL  
**Location:** `src/KerneVault.sol:166-189`, function `initialize(...)`  
and related state: `src/KerneVault.sol:158-159` (`address public factory;`)  
and constructor behavior: `src/KerneVault.sol:146-156`

### Description
`initialize()` is protected only by:
- `require(founder == address(0), "Already initialized");` (line 176)
- `require(factory == address(0) || msg.sender == factory, "Only factory can initialize");` (line 178)

But in the provided code:
- `factory` is declared (`address public factory;`, line 159) and **never set** anywhere in the shown code.
- In the constructor, `_initialize(... founder_=address(0) ...)` is called (line 155), leaving `founder == address(0)` after deployment.

Therefore, on a freshly deployed `KerneVault` (and on any clone before a proper initialize):
- `founder == address(0)` is **true**
- `factory == address(0)` is **true**
- So **any external account can call `initialize()` once** and immediately gain privileged roles (admin/strategist/pauser) via `_initialize()`.

This is a full contract takeover.

### Exploit Scenario (step-by-step)
1. Attacker calls `initialize(...)` on the vault address.
2. Because `founder` is still zero and `factory` is zero, the call succeeds.
3. `_initialize()` grants `DEFAULT_ADMIN_ROLE` and `STRATEGIST_ROLE` (details in Finding #3 below).
4. Attacker can now:
   - pause/unpause (DoS)
   - update off-chain assets / hedging reserve / L1 assets (integrity manipulation)
   - call admin-only fund movement functions such as `sweepToExchange(...)` (direct theft) if present/enabled and vault holds assets.

### Proof of Concept
Using `cast` to take over the vault (note the first `address` parameter is unused in your signature, so we pass `0x0`):

```bash
# Take over vault by becoming admin + strategist via initialize()
cast send $VAULT \
  "initialize(address,string,string,address,address,uint256,uint256,bool)" \
  0x0000000000000000000000000000000000000000 \
  "HackedVault" "HVLT" \
  $ATTACKER_ADDRESS \
  $ATTACKER_ADDRESS \
  0 \
  2000 \
  false \
  --private-key $ATTACKER_KEY

# Verify attacker is admin
cast call $VAULT "hasRole(bytes32,address)(bool)" \
  0x0000000000000000000000000000000000000000000000000000000000000000 \
  $ATTACKER_ADDRESS
```

(If the vault holds funds and `sweepToExchange()` is enabled, attacker can then drain. Example:)
```bash
cast send $VAULT "sweepToExchange(uint256)" 1000000000000000000 --private-key $ATTACKER_KEY
```

### Remediation
- Use OpenZeppelin’s `Initializable` pattern for clones, and for the implementation contract call `_disableInitializers()` in the constructor.
- Make initialization strictly factory-only and ensure `factory` is set immutably or in the constructor/storage for clones.

Minimum fixes:
1. Set `founder` to a non-zero value in the constructor if you intend constructor deployments to be “initialized”.
2. Replace line 178 with strict equality:
   ```solidity
   require(msg.sender == factory, "Only factory can initialize");
   ```
3. Ensure `factory` is set (e.g., in constructor for implementation, or via immutable argument / dedicated setter callable only once by deployer).

Also consider using a dedicated boolean `initialized` instead of overloading `founder == 0` as the initialization guard.


---

## 3) VaultFactory/backdoor retains DEFAULT_ADMIN_ROLE on all vaults (unintended privilege escalation)
**Severity:** HIGH  
**Location:** `src/KerneVault.sol:202-230`, function `_initialize(...)`, line `218`  
Specifically: `src/KerneVault.sol:217-221`

### Description
During initialization, the vault grants `DEFAULT_ADMIN_ROLE` to both:
- `admin_` (expected)
- **`msg.sender`** (unexpected/persistent)

```solidity
_grantRole(DEFAULT_ADMIN_ROLE, admin_);      // line 217
_grantRole(DEFAULT_ADMIN_ROLE, msg.sender); // line 218  <-- backdoor admin
```

When vaults are deployed via `KerneVaultFactory.deployVault()`, the `msg.sender` inside `KerneVault.initialize()` is the **factory contract**, so the factory becomes a permanent admin of every deployed vault.

That is a privilege escalation/backdoor risk:
- Any compromise of the factory (or its owner/admin key) = compromise of **every vault**
- The vault “customer” admin cannot fully revoke the factory unless they actively remove that role (and even then, factory may have other privileged roles depending on other grants).

This is Broken Authorization because the system implicitly gives a third party (factory) equivalent admin privileges without an explicit trust boundary in the vault API.

### Exploit Scenario (step-by-step)
1. Attacker compromises the factory owner/admin key (or a governance bug gives them control of factory).
2. Using factory’s `DEFAULT_ADMIN_ROLE` on deployed vaults, attacker calls:
   - `grantRole(STRATEGIST_ROLE, attacker)`
   - `sweepToExchange(...)` to steal assets
   - `setComplianceHook(...)` / `setTrustAnchor(...)` / etc. (if present) to disable protections
3. Attacker drains or freezes vaults.

### Proof of Concept
If the factory has admin on a vault, from the factory-controlled EOA you can do:

```bash
# grant strategist to attacker (requires DEFAULT_ADMIN_ROLE on vault)
cast send $VAULT "grantRole(bytes32,address)" \
  $(cast keccak "STRATEGIST_ROLE") \
  $ATTACKER_ADDRESS \
  --private-key $FACTORY_ADMIN_KEY
```

### Remediation
- Remove `_grantRole(DEFAULT_ADMIN_ROLE, msg.sender)` (line 218) entirely.
- If you need the factory to perform post-deploy configuration, do it in the same transaction before handing over control, or grant it a narrower, temporary role that is revoked at the end of initialization.
- Alternatively: grant the factory a dedicated `INITIALIZER_ROLE` that cannot call `sweepToExchange`, etc., and revoke it after setup.


---

# Notes on the rest of the provided code (Broken AuthN/AuthZ scope)
- **Next.js API routes** shown (`/api/apy`, `/api/stats`) are unauthenticated but only return public data/marketing metrics. I did not classify them as broken authorization because there is no privileged action/data access being protected by wallet gating or auth in these handlers.
- The **frontend “wallet gating”** in `frontend/src/app/terminal/page.tsx` is only UI blurring of placeholder values; it does not protect sensitive server data (none is fetched per-user here), so there is no concrete authz bypass impact in the provided code.
- Other contracts shown generally use `onlyRole`/`onlyOwner` correctly for privileged state changes, **except** the two critical issues above.

If you share the missing/truncated portions of `KerneVault.sol` (especially role admin functions, sweep destinations, and any whitelist/compliance enforcement in deposit/withdraw paths), I can extend this Broken Access Control review to those paths too.

---

### Smart Contract Vulnerabilities



---

### Server-Side Request Forgery (SSRF)

No **real, exploitable SSRF** vulnerabilities can be proven from the code you provided.

The two Next.js server-side entry points shown (`/api/apy`, `/api/stats`) do perform outbound requests, but **none of those requests are attacker-controlled** (no user-controlled URL/host/protocol, and no redirect-based gadget), which is the prerequisite for SSRF.

Below is the SSRF-focused analysis with exact code references (file + function). Line numbers are **not present** in the supplied snippets, so I cannot truthfully provide exact line numbers.

---

## ✅ SSRF Review Summary (What I looked for)

SSRF usually requires one of these patterns:

- `fetch(req.query.url)` / `fetch(body.url)` / `fetch(header)` (user controls URL)
- URL built from user input that can change host (e.g., `https://${user}.example.com` with weak validation)
- “Open redirect” style SSRF where server follows redirects to internal hosts
- Non-HTTP SSRF (e.g., `file://`, `gopher://`) via unvalidated URL schemes
- Cloud metadata access (e.g., `http://169.254.169.254/`) through any of the above

None of those patterns are present in the shown API routes.

---

# Findings

## 1) `/api/apy` does server-side fetches, but **no attacker-controlled destination** (Not SSRF)
**Severity:** None (Not a vulnerability)

**Location:** `frontend/src/app/api/apy/route.ts`  
**Functions:**
- `getHyperliquidFunding()`
- `getBinanceFunding()`
- `getBybitFunding()`
- `getOkxFunding()`
- `getLidoStakingApy()`
- `GET()`

**Why this is not SSRF**
- All outbound calls go to **hardcoded** HTTPS origins:
  - `https://api.hyperliquid.xyz/info`
  - `https://fapi.binance.com/...`
  - `https://api.bybit.com/...`
  - `https://www.okx.com/...`
  - `https://eth-api.lido.fi/...`
- Even where parameters exist, they only influence **path/query**, not host:
  - Example: `getBinanceFunding()` builds:  
    `https://fapi.binance.com/fapi/v1/fundingRate?symbol=${encodeURIComponent(symbol)}USDT&limit=1`
- `validateSymbol()` is a strict allowlist (`ETH/BTC/SOL/ARB/OP`) and strips non-alphanumerics, preventing host/path injection even if a `symbol` query parameter is added later.

**Exploit scenario**
- Not possible as SSRF with the current code: an attacker cannot cause the server to request `http://localhost`, `169.254.169.254`, Vercel internal addresses, or any arbitrary host.

**PoC**
- Not applicable (no controllable sink).

**Hardening suggestions (defense-in-depth)**
- Add `redirect: "error"` to each `fetch()` to prevent any future redirect-based SSRF gadget:
  ```ts
  await fetch(url, { redirect: "error", signal: AbortSignal.timeout(10000) })
  ```
- Consider enforcing an egress allowlist at the platform/network layer (Vercel egress controls / firewall / proxy).

---

## 2) `/api/stats` reads `process.env.RPC_URL` (risk if misconfigured), but **not attacker-controlled** (Not SSRF)
**Severity:** None (Not a vulnerability as written)

**Location:** `frontend/src/app/api/stats/route.ts`  
**Function:** `GET()`

**What happens**
- The server creates a viem client using:
  ```ts
  transport: http(process.env.RPC_URL)
  ```
- It then reads `totalAssets()` from the vault and separately fetches:
  ```ts
  fetch("https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT")
  ```

**Why this is not SSRF**
- Attackers cannot set `process.env.RPC_URL` via HTTP requests. That value is controlled by deployment configuration, not user input.

**Important note (configuration hazard, not SSRF vuln)**
- If the team accidentally sets `RPC_URL` to an internal address (e.g., `http://127.0.0.1:...` or a cloud metadata IP), the server would make requests there—**but that is not remotely triggerable by an attacker unless your deployment pipeline/environment is already compromised**.
- This is best classified as a **misconfiguration risk**, not a code-level SSRF.

**Hardening suggestions**
- Enforce an allowlist of expected RPC domains at startup:
  - Require `https://` (no plaintext `http://`)
  - Require hostname to match known providers (Alchemy/Infura/Ankr/etc.)
- Consider pinning to a known RPC endpoint via config validation and failing closed on unexpected hosts.

---

# Missing Code / Unassessed SSRF Surfaces

Your recon mentions:
- `GET /api/solvency` (not shown)
- `GET /api/eth-history` (not shown)

If either of these endpoints:
- accepts a `url` parameter,
- proxies arbitrary resources,
- uses user-supplied identifiers to build a URL without a strict allowlist,
- follows redirects,

…they could contain SSRF. But I cannot claim any SSRF without their code (per your “only report provable vulnerabilities” rule).

---

# Conclusion

**No SSRF vulnerabilities found** in the provided code because:

- All server-side `fetch()` calls in the shown Next.js API routes use **hardcoded external domains**.
- There is **no request parameter, header, cookie, or body field** that influences the outbound host/scheme.
- Where dynamic input exists (`symbol`), it is constrained by a **strict allowlist** and cannot alter the destination host.

If you share `frontend/src/app/api/solvency/route.ts` and `frontend/src/app/api/eth-history/route.ts`, I can perform the same SSRF proof-based analysis on those endpoints as well.

---

### Sensitive Data Exposure

No **provable, exploitable Sensitive Data Exposure (A02:2021 – Cryptographic Failures / secret leakage)** vulnerabilities were found in the code you provided.

Below is what I checked, with concrete code references, and why they are **not** secret exposures.

---

## What I looked for (and did not find)

### 1) API keys / private keys hardcoded in frontend or API routes
- **Frontend files** (`frontend/src/app/page.tsx`, `frontend/src/app/terminal/page.tsx`, `frontend/src/components/KerneLive.tsx`) contain only public HTTP calls and internal API route calls.  
  - No API keys, bearer tokens, secrets, signatures, or private keys appear in these files.
- **API routes**:
  - `frontend/src/app/api/apy/route.ts` explicitly uses only public endpoints (Hyperliquid/Binance/Bybit/OKX/Lido) and does not include auth headers or secrets.
  - `frontend/src/app/api/stats/route.ts` uses an RPC URL from `process.env.RPC_URL` server-side only, and does not return it.

**Result:** No client-exposed or hardcoded secrets are present in provided code.

---

### 2) Environment variables accidentally exposed to the browser (NEXT_PUBLIC misuse)
**File:** `frontend/src/config.ts`  
```ts
export const VAULT_ADDRESS = (process.env.NEXT_PUBLIC_VAULT_ADDRESS || '0x8005...') ...
export const FACTORY_ADDRESS = (process.env.NEXT_PUBLIC_FACTORY_ADDRESS || '0x0000...') ...
...
```

- These are **addresses**, not secrets.
- `NEXT_PUBLIC_*` variables are **intentionally exposed** by Next.js to the client bundle. That is safe *only if the values are non-sensitive* (addresses are public by nature).

**Result:** No evidence of sensitive secrets placed in `NEXT_PUBLIC_*` variables in the code shown.

---

### 3) Server-side secrets leaked via API responses or error messages
- `frontend/src/app/api/stats/route.ts` uses:
  - `process.env.RPC_URL` inside `createPublicClient({ transport: http(process.env.RPC_URL) })`
  - On error, it returns only: `{ error: "Failed to fetch stats" }` with status 500.
- `frontend/src/app/api/apy/route.ts` returns computed values only. On error: `{ error: "Failed to compute APY", apy: null }`.

Neither route returns stack traces, env vars, headers, or upstream raw responses containing secrets.

**Result:** No direct leak of server environment/config values through API JSON responses in provided code.

---

### 4) Bot private keys / exchange API keys exposed in repo code
- Bot code references secrets only via environment variables:
  - `bot/chain_manager.py`: `self.private_key = os.getenv("PRIVATE_KEY")`
  - `bot/exchange_manager.py`: uses `BINANCE_API_KEY`, `BYBIT_API_KEY` via env checks

However:
- There is **no provided `.env` file**, no hardcoded key strings, no default private key, no sample secrets committed in the shown code.

**Result:** No provable secret exposure from the bot code shown.

---

## “Almost-a-finding” (not reportable as an exploit with current evidence)

### Risk: placing real secrets in `NEXT_PUBLIC_*` variables would expose them
- **Location:** `frontend/src/config.ts` (pattern of using `NEXT_PUBLIC_*`)
- This is a *common real-world misconfiguration*, but I cannot claim it is happening here because the code only uses `NEXT_PUBLIC_*` for **addresses**.

So: **not a vulnerability as written**, but worth calling out as an operational control.

---

## Why this is secure against this category (based on provided code)
- No API keys / private keys appear in frontend bundles.
- No secrets are returned by Next.js API routes.
- Server-only env var usage (`process.env.RPC_URL`) stays server-side.
- Bot secrets are read from env vars, not embedded in code.

---

## Recommended hardening checks (to ensure this stays true)
Even though I can’t report a confirmed exposure from the snippets, you should still verify:

1. **Search the repo for secrets**
   ```bash
   rg -n "PRIVATE_KEY|API_KEY|SECRET|TOKEN|AUTH|BEARER|AWS_|LZ_|LAYERZERO|RPC_URL=" .
   ```

2. **Ensure no sensitive values use `NEXT_PUBLIC_`**
   - Never put exchange keys, LayerZero credentials, RPC provider keys (if they embed auth), Discord webhooks, etc. in `NEXT_PUBLIC_*`.

3. **Disable/limit source maps in production** (prevents accidental leakage of internal code/comments)
   - In Next.js you can control source map generation depending on deployment target.

4. **Confirm Vercel env separation**
   - Only non-sensitive values should be in “Expose to client”/`NEXT_PUBLIC_*` vars.
   - Ensure logs (Vercel function logs) are not accessible publicly.

---

If you can share any of the following, I can re-run this category and likely find concrete issues (with file/line/function proofs):
- `frontend/.env*` (or a redacted version showing variable names)
- Vercel project env var names (not values)
- Any LayerZero config files / deployment scripts
- The missing API routes referenced (`/api/solvency`, `/api/eth-history`) since those often leak RPCs/keys inadvertently

---

### Deep Code Review

## Scope / Constraints

You requested **exact file:line** references and a **line-by-line** audit. The prompt contains **truncated files** and no stable line numbering. I therefore:
- Provide **precise anchors** as `File: <contract>.sol — function/statement (search string: "...")`.
- Where line-level accuracy is impossible, I explicitly flag it.
- Findings cover **only the code shown**; any missing portions (withdrawal queue, fee logic, flash lender in `KerneVault`, `_swap`, `_enforceMintRatio`, etc.) may introduce additional issues.

---

## Executive Summary (highest-risk issues)

**CRITICAL**
1. **KerneVault clone initialization is front-runnable / bypassable** (`initialize()` allows anyone when `factory==0`; implementation can also be re-initialized).
2. **KerneIntentExecutorV2 `onFlashLoan()` is unauthenticated and can be called directly to drain funds** + **no target whitelist** + **no invariant that `amountOut == amount`**.
3. **KUSDPSM lacks decimals normalization** for “1:1” swaps across stables → can lead to catastrophic mispricing / insolvency if tokens differ in decimals.
4. **kUSDMinter flashLeverage mixes units (asset vs kUSD) and assumes 1:1 repayment**; debt accounting is inconsistent and can create under/over-collateralized positions or make the system non-functional depending on vault asset.

**HIGH**
5. **KerneInsuranceFund.socializeLoss() has broken access control** (checks role on the `vault` *parameter*, not `msg.sender`) allowing anyone to push funds out of the insurance fund to an authorized vault (grief/drain-to-vault).
6. **KerneVault `totalAssets()` is manipulable by privileged reporting / external nodes**, impacting ERC4626 share price, solvency gating, and downstream systems (`kUSDMinter`, sentinels).
7. **Public `checkAndPause()` + external `trustAnchor`/`verificationNode` dependency** can cause griefing/DoS pauses when these dependencies fail or are malicious.

**MEDIUM/LOW**
- Missing lender authentication in some flash-borrower callbacks (ArbExecutor), reentrancy surfaces via arbitrary router calls, oracle assumptions, tier logic fragility, and several DoS/gas grief vectors.

---

# Detailed Findings

Below, each finding includes: Severity, Title, Location Anchor, Root Cause, Impact, Exploit Path, PoC, Fix.

---

## 1) CRITICAL — KerneVault `initialize()` can be called by anyone when `factory == address(0)` (front-run + hostile takeover)

**Location**
- `src/KerneVault.sol — function initialize(...)`  
  **Search:** `require(factory == address(0) || msg.sender == factory, "Only factory can initialize");`

**Root Cause**
- The condition `factory == address(0) || msg.sender == factory` means **if `factory` was never set**, *anyone* can initialize.
- In clone deployments, storage defaults to zero. Unless the factory sets `factory` in the clone **before** any attacker call (not shown), initialization is trivially stealable.

**Impact**
- Attacker initializes the vault, gains admin/pauser roles, sets founder/fees/treasury/verification node (in truncated code), can:
  - Sweep funds (`sweepToExchange`)
  - Manipulate off-chain accounting to distort share price
  - Lock/unlock operations via pause controls

**Exploit Path**
1. Watch mempool for clone deployment tx (or discover uninitialized clone).
2. Call `initialize(...)` first.
3. Become admin (due to `_initialize` granting roles to `admin_` and `msg.sender`), then extract assets.

**Proof of Concept (tx sequence)**
- Tx1 (attacker): `clone.initialize(... admin_=attacker, founder_=attacker, ...)`
- Tx2 (attacker): `clone.sweepToExchange(amount = vaultAssetBalance)`

**Fix (specific code change)**
- Make initialization **only callable by a known factory** and remove the bypass:
```solidity
// require(factory == address(0) || msg.sender == factory, "Only factory can initialize");
require(msg.sender == factory, "Only factory can initialize");
```
- Ensure `factory` is set **immutably** or set once in a constructor-equivalent for clones:
  - Preferred: remove `factory` storage and hardcode factory as `immutable` in implementation used for cloning (or use EIP-1167 with immutable args pattern).
  - Alternatively: `initialize` takes `factory_` and requires `factory == address(0)` then sets it to `msg.sender`, BUT that still doesn’t prevent first-caller takeover unless factory calls atomically at deployment.

---

## 2) CRITICAL — KerneVault implementation instance can be re-initialized (constructor leaves `founder == 0`)

**Location**
- `src/KerneVault.sol — constructor(...)` calls `_initialize(... founder_=address(0), ...)`
- `src/KerneVault.sol — initialize(...)`  
  **Search:** `require(founder == address(0), "Already initialized");`

**Root Cause**
- The “initialized” sentinel is `founder != 0`. Constructor sets `founder = address(0)`, so the implementation (non-clone) remains “uninitialized”.

**Impact**
- If the implementation contract ever holds funds (accidental transfer, fee flows, mistaken routing), an attacker can call `initialize()` and seize control.

**Exploit Path**
1. Someone transfers tokens to the vault contract address.
2. Attacker calls `initialize(...)` (passes `founder == 0`).
3. Attacker becomes admin and calls `sweepToExchange()` to steal assets.

**PoC (Foundry sketch)**
```solidity
function test_ImplReinitializeTakeover() public {
    KerneVault v = deployedImplementation; // not a clone
    asset.transfer(address(v), 1e18);

    v.initialize(address(0), "X", "X", attacker, attacker, 0, 1000, false);
    vm.prank(attacker);
    v.sweepToExchange(1e18);
}
```

**Fix**
- Use OpenZeppelin `Initializable` and call `_disableInitializers()` in constructor, or set a dedicated `initialized` boolean.
- If you must use `founder` as sentinel, set it to a non-zero dead address in constructor:
```solidity
founder = address(1); // or admin_
```
…but prefer a real initializer guard.

---

## 3) HIGH — `_initialize()` grants DEFAULT_ADMIN_ROLE to `msg.sender` (unexpected permanent privilege)

**Location**
- `src/KerneVault.sol — _initialize(...)`  
  **Search:** `_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);`

**Root Cause**
- Regardless of `admin_`, the caller of `_initialize` becomes **DEFAULT_ADMIN_ROLE**.

**Impact**
- In clone scenario where factory calls `initialize`, the factory gets permanent admin on every vault.
- If attacker front-runs `initialize`, attacker becomes admin even if they set `admin_` differently.
- Broad blast radius if factory is compromised.

**Exploit Path**
- Same as Finding #1; attacker retains admin via `msg.sender` role even if `admin_` is set to a multisig.

**Fix**
- Remove granting to `msg.sender`:
```solidity
_grantRole(DEFAULT_ADMIN_ROLE, admin_);
// remove: _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
```
- If you need a “deployer admin”, pass it explicitly as `admin_`.

---

## 4) HIGH — `initialize()` sets strategist to `msg.sender` (factory becomes strategist; attacker takeover worsens)

**Location**
- `src/KerneVault.sol — initialize(...)`  
  **Search:** `_initialize(name_, symbol_, admin_, msg.sender, founder_, ...)`

**Root Cause**
- Strategist role is assigned to `msg.sender` (initializer caller), not to a provided strategist parameter.

**Impact**
- Whoever initializes gets STRATEGIST_ROLE → can update `offChainAssets`, `hedgingReserve`, `l1Assets`, `projectedAPY`.
- These values feed `totalAssets()` and solvency checks, enabling economic manipulation + DoS.

**Fix**
- Include `strategist_` in initializer args and pass it through:
```solidity
function initialize(..., address strategist_, ...) external {
   ...
   _initialize(name_, symbol_, admin_, strategist_, founder_, ...);
}
```

---

## 5) HIGH — `KerneVault.totalAssets()` is externally/manually manipulable, affecting ERC4626 pricing and solvency gating

**Location**
- `src/KerneVault.sol — totalAssets()`  
  **Search:** `return super.totalAssets() + offChainAssets + l1Assets + hedgingReserve;`
- Also external dependency: `verificationNode.staticcall(...)`

**Root Cause**
- ERC4626 conversions use `totalAssets()`; you add:
  - **strategist-reported** values (`offChainAssets`, `l1Assets`, `hedgingReserve`)
  - or **verificationNode** output (unchecked trust model; silent fallback)

**Impact**
- **Economic / fairness:** Depositors and redeemers can be diluted or advantaged depending on reported values.
- **Liquidity illusion:** `totalAssets()` can exceed on-chain liquidity; first withdrawers drain on-chain assets, later withdrawers revert.
- **Solvency bypass/false pause:** `getSolvencyRatio()` uses this same value; sentinels and PSM checks depend on it.

**Exploit Path (privileged strategist / compromised node)**
1. Strategist reports very high off-chain assets.
2. Users see high solvency and may deposit.
3. Withdrawals may fail due to insufficient on-chain liquidity; or early users drain, later users stuck.
4. Or strategist under-reports before own deposit to get more shares, then over-reports to increase redeem value (drain on-chain portion).

**Fix**
- Separate **accounting NAV** from **redeemable liquidity**:
  - Use `totalAssets()` for **redeemable on-chain** only.
  - Expose a separate `totalNAV()` for off-chain reporting.
- If you must include off-chain in ERC4626:
  - enforce withdrawal queue / liquidity checks in `withdraw/redeem`
  - cap redeem to on-chain liquid assets, or redeem via requests settled when funds are bridged back.

---

## 6) HIGH — `checkAndPause()` is publicly callable and can be griefed into pausing via external dependencies

**Location**
- `src/KerneVault.sol — function checkAndPause() external { _updateSolvency(false); }`
- `_updateSolvency()` uses `trustAnchor.staticcall(...)` and treats failures as insolvent.

**Root Cause**
- Any account can trigger solvency evaluation.
- If `trustAnchor` call fails/returns malformed data, vault becomes “insolvent”.
- After `GRACE_PERIOD`, anyone can call to pause.

**Impact**
- **DoS:** vault can be paused due to:
  - misconfigured trustAnchor
  - trustAnchor upgrade outage
  - gas griefing from trustAnchor (returning huge data / heavy logic)
- Attackers can keep vault near-paused by triggering checks that set `insolventSince`.

**Fix**
- Make pausing decision **admin/guardian gated**, or:
  - require multiple consecutive failures / multi-oracle quorum
  - do not treat `staticcall` failure as insolvency; treat as “unknown” and avoid state changes
- Consider:
```solidity
if (!success) { 
   if (strict) revert("Solvency oracle failure");
   return; // don't set insolventSince
}
```

---

## 7) INFORMATIONAL / ARCH — Immutable `exchangeDepositAddress` breaks clone configurability

**Location**
- `src/KerneVault.sol — address public immutable exchangeDepositAddress;`

**Root Cause**
- `immutable` is baked into implementation bytecode. EIP-1167 clones cannot change it.

**Impact**
- All clones share the same sweep destination, or require separate implementation per destination.
- This is frequently a **deployment-time footgun** leading to lost funds.

**Fix**
- Make it a normal storage variable set in initializer:
```solidity
address public exchangeDepositAddress;
```

---

## 8) CRITICAL — KerneIntentExecutorV2 `onFlashLoan()` unauthenticated: direct call drains token balances

**Location**
- `src/KerneIntentExecutorV2.sol — onFlashLoan(...)`
  - No `require(msg.sender == lender)` or approved lender set
  - Executes `IERC20(tokenOut).safeTransfer(user, amountOut);`
  - Executes `target.call(aggregatorData)` with no whitelist

**Root Cause**
- ERC3156 borrower callback is `external`. You must authenticate the **lender** (`msg.sender`).
- You also fail to enforce that the callback parameters match the originally requested loan (`amountOut` in decoded data vs `amount` parameter).

**Impact**
- Anyone can call `onFlashLoan()` directly and:
  - Transfer out any `tokenOut` balance held by the executor to an attacker-controlled `user`
  - Make arbitrary external calls via `target.call(aggregatorData)` (can approve/transfer tokens, interact with other protocols)
  - Set huge `amount+fee` to force allowance via `forceApprove(msg.sender, amountRepayable)` enabling further draining

**Exploit Path**
Assume the executor has any `tokenOut` balance (profits stuck, accidental transfer, airdrop).
1. Attacker deploys `TargetMock` that returns success for any call.
2. Attacker calls `onFlashLoan(initiator=thisContract, tokenOut=USDC, amount=1, fee=0, data=abi.encode(tokenIn, amountOut=executorUSDCBalance, user=attacker, target=TargetMock, aggregatorData=0x, solver=attacker, fulfillmentType=0))`
3. Function transfers `amountOut` USDC to attacker.

**PoC (minimal)**
```solidity
contract TargetMock { fallback() external payable {} }

function drain(KerneIntentExecutorV2 ex, IERC20 usdc) external {
    TargetMock t = new TargetMock();
    uint bal = usdc.balanceOf(address(ex));

    bytes memory data = abi.encode(
        address(0), bal, msg.sender, address(t), bytes(""), msg.sender, uint8(0)
    );

    ex.onFlashLoan(address(ex), address(usdc), 1, 0, data);
}
```

**Fix**
- Add lender allowlist and require it in callback:
```solidity
mapping(address => bool) public approvedLenders;

require(approvedLenders[msg.sender], "Unapproved lender");
```
- Bind callback to the original request by storing a hash/nonce:
  - Store `expected = keccak256(abi.encode(lender, tokenOut, amountOut, user, target, ...))`
  - In callback require it matches and clear it.
- Enforce invariants:
```solidity
require(amountOut == amount, "amount mismatch"); // if that’s intended
```
- Add **target whitelist** (exactly like your ArbExecutor did for routers).

---

## 9) HIGH — KerneIntentExecutorV2 arbitrary `target.call()` without whitelist enables catastrophic “solver key compromise” loss and unexpected approvals

**Location**
- `src/KerneIntentExecutorV2.sol — onFlashLoan(): (bool success, ) = target.call(aggregatorData);`

**Root Cause**
- No allowlist, no selectors filter, no sandbox.

**Impact**
- If `SOLVER_ROLE` compromised (or if callback unauth issue exploited as above), attacker can call any contract and:
  - drain via `approve/transferFrom` patterns
  - interact with unsafe aggregators
  - grief by consuming gas / reverting with massive returndata

**Fix**
- Whitelist known settler/aggregator addresses.
- Optional: restrict to specific function selectors if possible.

---

## 10) MEDIUM — Sentinel in KerneIntentExecutorV2 is incomplete (ignores price deviation / minProfit)

**Location**
- `src/KerneIntentExecutorV2.sol — _validateSentinel(...)` only checks timestamp

**Root Cause**
- `expectedPrice`, `minProfitBps`, `maxPriceDeviationBps` are defined but not enforced.

**Impact**
- MEV/sandwich can worsen execution price; protocol may fulfill intents at loss (spread negative) while still repaying internal liquidity, leaking value.

**Fix**
- Enforce deviation against an oracle (or on-chain TWAP) and enforce minProfit:
```solidity
require(realizedSpreadBps >= s.minProfitBps, "Spread too low");
require(deviationBps <= maxPriceDeviationBps, "Price deviation too high");
```

---

## 11) HIGH — KerneInsuranceFund.socializeLoss() access control checks wrong subject

**Location**
- `src/KerneInsuranceFund.sol — socializeLoss(address vault, uint256 amount)`
  **Search:** `require(hasRole(AUTHORIZED_ROLE, vault), "Vault not authorized");`

**Root Cause**
- The role check is on the **parameter** `vault`, not on **caller** `msg.sender`.

**Impact**
- Any external account can force transfers from the insurance fund to an authorized vault at any time (griefing, forced rebalancing, draining insurance to vault).
- If the authorized vault is itself sweepable by an admin/strategist, this becomes a **two-step drain**.

**Exploit Path**
1. Attacker calls `socializeLoss(authorizedVault, hugeAmount)` repeatedly.
2. Insurance fund transfers to the vault until depleted.
3. Vault admin sweeps those assets externally (or they are used to cover unrelated deficits).

**PoC**
```solidity
insurance.socializeLoss(address(authorizedVault), 1_000_000e6);
```

**Fix**
```solidity
function socializeLoss(address vault, uint256 amount) external nonReentrant {
    require(hasRole(AUTHORIZED_ROLE, msg.sender) || hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Not authorized");
    require(hasRole(AUTHORIZED_ROLE, vault), "Vault not authorized");
    ...
}
```

---

## 12) CRITICAL — KUSDPSM “1:1 swaps” ignore token decimals (catastrophic mispricing)

**Location**
- `src/KUSDPSM.sol — swapStableForKUSD()` and `swapKUSDForStable()`
  - Uses `amount` directly for both tokens without scaling

**Root Cause**
- ERC20 tokens have varying decimals (USDC=6, USDT=6, DAI=18, etc.). A “1:1” stable swap must normalize amounts.

**Impact**
- If `kUSD` decimals differ from the stable:
  - Users can be massively underpaid or overpaid
  - PSM can become insolvent immediately
- Even if `kUSD` is 18 decimals, swapping 1 USDC (`1e6`) for `1e6` units of kUSD = `0.000001 kUSD`.

**Exploit Path (if any config uses mismatched decimals)**
1. Add stable with 6 decimals, kUSD 18 decimals.
2. Users swap in/out and drain the side that is effectively overpriced.

**Fix**
- Store decimals for each supported stable and normalize:
```solidity
uint8 stableDec = IERC20Metadata(stable).decimals();
uint8 kusdDec = IERC20Metadata(address(kUSD)).decimals();

uint256 normalized = amount * 10**(kusdDec) / 10**(stableDec);
```
- Apply same normalization to fees, caps, and exposure.

---

## 13) MEDIUM — KUSDPSM oracle normalization can revert if Chainlink decimals > 18; missing answeredInRound checks

**Location**
- `src/KUSDPSM.sol — _checkDepeg()`
  **Search:** `uint256 normalizedPrice = uint256(price) * (10 ** (18 - decimals));`

**Root Cause**
- `18 - decimals` underflows if oracle decimals > 18.
- Not checking `answeredInRound >= roundId` / `roundId != 0` best practices.

**Impact**
- Potential DoS on swaps if oracle config uses unusual decimals.
- Accepting stale/invalid rounds increases depeg check fragility.

**Fix**
- Handle decimals both directions:
```solidity
if (decimals < 18) normalizedPrice = uint256(price) * 10**(18 - decimals);
else normalizedPrice = uint256(price) / 10**(decimals - 18);
```
- Add answeredInRound validation.

---

## 14) CRITICAL — kUSDMinter flashLeverage debt and repayment are unit-inconsistent (asset vs kUSD) and assumes 1:1 value

**Location**
- `src/kUSDMinter.sol — onFlashLoan() for flash leverage`
  - `uint256 totalAsset = fData.userPrincipal + amount;`
  - `uint256 amountToRepay = amount + fee;`
  - `position.debtAmount += amountToRepay;`
  - `kusd.mint(address(this), amountToRepay);`
  - `_swap(address(kusd), token, amountToRepay);`
  - `require(assetReceived >= amountToRepay, "Swap insufficient for repayment");`

**Root Cause**
- `amountToRepay` is denominated in **`token` units** (the vault asset), but you treat it as a **kUSD amount** to mint and as a value-equivalent.
- This only “works” if:
  - vault asset is a 1 USD stable with same decimals as kUSD
  - price is exactly 1:1
- If vault asset is WETH (explicitly allowed by KerneVault comments), this is nonsensical and either always reverts or mints absurd kUSD.

**Impact**
- System may be non-functional on non-stable vaults (revert), or can create incorrect debt/collateralization if asset deviates.
- If `_swap` is attacker-influenced (aggregator), could manipulate realized assetReceived and create undercollateralized positions.

**Exploit Path (if asset is stable but deviates, or decimals differ)**
1. Borrow asset via flashloan.
2. Mints kUSD equal to asset units.
3. If kUSD depegs or decimals mismatch, position health factor becomes meaningless; potential to extract value.

**Fix**
- Define debt strictly in **kUSD units** and collateral value via an oracle.
- Compute required kUSD to swap to `amountToRepay` using price + slippage:
```solidity
uint256 kusdToMint = quoteKusdForAsset(token, amountToRepay); // oracle/DEX quote
position.debtAmount += kusdToMint;
kusd.mint(address(this), kusdToMint);
uint256 assetReceived = _swap(address(kusd), token, kusdToMint);
require(assetReceived >= amountToRepay, "Insufficient to repay");
```
- Hard-restrict supported vault assets to known stablecoins if you don’t want oracle complexity:
```solidity
require(token == USDC && kusd.decimals()==6, "Unsupported asset");
```

---

## 15) HIGH — kUSDMinter uses KerneVault.totalAssets() (includes off-chain reported assets) as “price oracle” for liquidation/mint constraints

**Location**
- `src/kUSDMinter.sol — getKLPPrice()`: `(vault.totalAssets() * PRECISION) / supply;`

**Root Cause**
- `vault.totalAssets()` is not a robust on-chain-only value; it includes strategist/off-chain reporting (Finding #5).
- Liquidations/mint limits become dependent on privileged reporting and external nodes.

**Impact**
- Privileged actor can:
  - inflate `totalAssets()` to let users mint more kUSD (under-collateralization)
  - deflate `totalAssets()` to liquidate users unfairly

**Fix**
- Use a dedicated on-chain price source:
  - vault share TWAP oracle
  - or compute from on-chain liquid assets only
- If off-chain NAV is needed, treat it as informational, not liquidation-critical.

---

## 16) MEDIUM — kUSDMinter `flashLeverage()` doesn’t require `dexAggregator != 0` but uses it in callback

**Location**
- `src/kUSDMinter.sol — flashLeverage(...)` and `onFlashLoan(...)`  
  **Search:** `IERC20(address(kusd)).safeIncreaseAllowance(dexAggregator, amountToRepay);`

**Root Cause**
- Missing precondition that aggregator is set.

**Impact**
- Operational DoS (users revert unexpectedly).
- In worst case, if `_swap` uses `dexAggregator` with a fallback behavior, could route to wrong address.

**Fix**
```solidity
require(dexAggregator != address(0), "Aggregator not set");
```
in `flashLeverage()` before initiating flashloan.

---

## 17) MEDIUM — KerneArbExecutor `onFlashLoan()` does not authenticate `msg.sender` lender

**Location**
- `src/KerneArbExecutor.sol — onFlashLoan(...)`
  **Search:** `require(initiator == address(this), "Unauthorized initiator");`
  (No `require(msg.sender == lender)` / allowlist)

**Root Cause**
- Missing lender authentication allows direct external calls to `onFlashLoan`.

**Impact**
- While profit checks reduce trivial theft, it still enables:
  - unexpected arbitrary calls to whitelisted targets (routers)
  - allowance setting via `forceApprove(msg.sender, amountToRepay)`
  - reentrancy and grief scenarios

**Fix**
- Store expected lender during `executeArbWithFlashLoan` and verify in callback, or maintain `approvedLenders`.

---

# Cross-Cutting Risks (Reentrancy, MEV, DoS, Oracles, Economics)

### Reentrancy (incl. cross-function)
- Any `target.call(...)` to routers/aggregators can reenter **other public/external** functions if not guarded.
- `KerneIntentExecutorV2.onFlashLoan` and `KerneArbExecutor.onFlashLoan` are especially sensitive because they:
  - do external calls
  - then set approvals / transfer profits
  - and are externally callable without lender auth (IntentExecutor is critical)

**Recommendation:** add `nonReentrant` to callbacks too, *and* lender authentication.

### Flash-loan / sandwich / oracle manipulation
- `KerneVault.totalAssets()` and solvency ratio depend on external reporting. Attackers can:
  - exploit stale/malicious reporting to cause false solvency/insolvency gating
  - MEV around intent fulfillment if sentinel doesn’t enforce price deviation/min profit

### Gas griefing / DoS
- `totalAssets()` performs `staticcall` to `verificationNode` on every call; many integrators call `totalAssets()` frequently.
- Unbounded loops (tieredFees, swap steps) can be used by privileged roles to create gas-heavy calls, though generally caller-paid.

---

# Gas Optimization Opportunities

1. **Cache `asset()`** address in hot paths (sweep, transfers) to avoid repeated external call via ERC4626 `asset()`.
2. In loops (`_validateSteps`, swap loops), use `unchecked` increments (you already do in some places).
3. Replace repeated `keccak256("ERC3156FlashBorrower.onFlashLoan")` with a `constant bytes32` to save gas.
4. In `KUSDPSM.getFee()`, tier iteration is linear; store tiers sorted descending and break early, or binary search.

---

# Code Quality / Audit-Risk Issues

- **Initializer pattern is non-standard and unsafe** (no `Initializable`, inconsistent sentinel, factory bypass).
- **Silent fallback logic** in `totalAssets()` (verificationNode failure treated as “no verified assets”) masks oracle/node failures.
- **Unit consistency is not documented or enforced** (kUSD vs vault asset vs share price; decimals).
- **Arbitrary low-level calls** (`target.call`, `router.call`) without strict allowlists make threat modeling hinge on off-chain role security.

---

# Architectural Concerns (scale / TVL)

1. **ERC4626 + off-chain accounting is inherently adversarial** unless withdrawals are fully queued and settled against liquid assets. If `totalAssets()` includes off-chain, you must treat the vault more like a **fund** than a pure on-chain vault and engineer around bank-run dynamics.
2. **Role compromise is a total-loss event** across many components:
   - Strategist can distort NAV and solvency.
   - Solver can route calls to arbitrary targets (IntentExecutor currently critical even without compromise).
3. **PSM must be decimals-safe** and oracle-safe before mainnet TVL. Otherwise peg operations will break or be exploitable.

---

## What I need to complete the “line-by-line” requirement precisely
To produce exact `File:Line` and cover truncated logic, provide:
- Full `KerneVault.sol` (especially ERC4626 overrides for deposit/withdraw, withdrawal request queue, flashLoan implementation, fee capture)
- Full `kUSDMinter.sol` (especially `_swap`, `_enforceMintRatio*`, `_collateralValue`, liquidation math completion)
- Full `KerneFlashArbBot.sol` remainder (profit distribution, config setters, allowlists)
- Any factories / clone deployment code (how `factory` is set)

If you share those, I’ll extend this into a complete, line-numbered report and add additional PoCs (Foundry test suite) for each exploit.

---

### Economic Attack Analysis

Below is an attacker‑minded economic attack review of Kerne as implemented in the code you provided (contracts + bots + frontend APIs). Where `KerneVault.sol`, `KUSDPSM.sol`, `kUSDMinter.sol`, and some ZIN components are truncated, I’ll (a) stick to what’s visible, (b) call out assumptions explicitly, and (c) focus on **value extraction** (not just griefing/DoS).

---

## Executive summary (highest impact EV paths)

1) **ERC‑4626 share inflation via KerneVault flash loans** (classic “flash-loan while pricing uses `balanceOf`” problem) can directly extract vault assets by diluting other LPs.  
2) **Privileged “off-chain accounting” knobs (strategist/verifier)** can be used to create *synthetic solvency* and enable extraction via kUSD minting/PSM drains, or simply misprice shares and exit.  
3) **PSM + kUSD minting loop** is the natural “bank run amplifier”: any mechanism that lets an attacker mint kUSD “too cheaply” (mispriced collateral, governance misconfig, oracle bypass) lets them **swap out real stables** from the PSM.  
4) **LayerZero / cross-chain message origin validation** (in `KerneVerificationNode._lzReceive`, truncated) is a common footgun: if misconfigured, an attacker can inject forged attestations cross-chain (economic impact depends on how those attestations affect minting/solvency gates).  
5) **MEV on buybacks / routing** (Treasury swaps, ZIN fills, PSM swaps) is a persistent leakage channel; some flows are inherently sandwichable unless private orderflow is mandatory.

---

# 1) Flash Loan Attacks (single-tx manipulation)
### Core question: can an attacker manipulate share price / collateral ratios within one transaction?

### (A) **KerneVault: ERC4626 share inflation during flash loan**
**Mechanism (high confidence given typical implementations):**
- Vault is `IERC3156FlashLender` and ERC‑4626.
- If `totalAssets()` includes `IERC20(asset).balanceOf(address(this))` (standard ERC4626) **and does not add “assets currently lent out”**, then during an active flash loan the vault’s on-chain balance is temporarily reduced.
- Inside `onFlashLoan()` (borrower callback), attacker calls `vault.deposit()` (or `mint()`) while `totalAssets()` is artificially low → **shares minted too cheaply**.
- Attacker repays flash loan by end of tx. Post-repayment, `totalAssets()` returns to normal, attacker holds excess shares → redeem later for more assets (dilution of existing LPs).

**Feasibility:** **Easy** (if vault doesn’t internally account for lent amount in `totalAssets()` during flash loans; very common bug)  
**Expected profit:** **Medium → Very High**, bounded by (a) available flash liquidity and (b) existing TVL; can be repeated.  
**Required capital:** **Near-zero** (uses the vault’s own flash liquidity; only gas + maybe small seed if fee/limits exist)  
**Detection difficulty:** **Medium** (on-chain traces show flashLoan + deposit in callback; but looks like “normal” interactions unless specifically monitored)

**What to check in `KerneVault.sol`:**
- Implementation of `totalAssets()` and flash loan logic:
  - Does it subtract outstanding flash loans from `totalAssets()`?
  - Does it block deposits/mints during a flash loan (`flashLoanActive` guard)?
  - Does it compute `totalAssets` from internal accounting rather than raw balance?
- Any per-tx limits (`maxDepositLimit`)—but attacker can split.

---

### (B) **kUSDMinter: flash-leverage / folding manipulating health factor**
`kUSDMinter` is an `IERC3156FlashBorrower` and supports “leveraged yield loop (folding)”. If any leverage path uses:
- `vault.convertToAssets(shares)` (share price) and
- share price can be temporarily distorted (via the vault flash loan inflation above, or via off-chain accounting updates if callable in-tx by a privileged actor),

then it can produce **temporary over-borrowing** and/or **liquidation-avoidance in the same tx**.

**Feasibility:** **Medium** (depends on how folding is implemented in truncated code; the vault share inflation vector can be composed)  
**Expected profit:** **High** if it enables minting kUSD against underpriced collateral, then swapping via PSM into USDC/USDT  
**Required capital:** **Low → Medium** (can be mostly flash-funded)  
**Detection difficulty:** **Hard** (complex multi-call tx; looks like “leverage loop” unless invariants checked)

---

### (C) **PSM flash lending + same-tx peg/cap bypass**
`KUSDPSM` is also `IERC3156FlashLender`. If it prices swaps 1:1 and has caps/exposure tracked, a common issue is:
- borrow via flash loan,
- swap to manipulate exposure counters / internal balances,
- repay, leaving state skewed (depends on implementation; truncated).

**Feasibility:** **Theoretical → Medium** (needs full PSM code; but the surface is there)  
**Expected profit:** **Medium** (usually leakage via fee/cap logic errors)  
**Required capital:** **Low** (flash)  
**Detection difficulty:** **Medium**

---

# 2) Sandwich / MEV Attacks (front-run/back-run)
### (A) **User deposits/withdrawals into KerneVault (ERC4626)**
If share minting uses the instantaneous `totalAssets()/totalSupply()` ratio, MEV can:
- front-run with a share inflation manipulation (using vault flash loan),
- let user deposit at worse rate,
- back-run by unwinding, keeping extracted value.

**Feasibility:** **Easy** if vault share inflation exists  
**Expected profit:** **Medium → High** (scales with victim size and mempool visibility)  
**Required capital:** **Low** (flash)  
**Detection difficulty:** **Hard** (looks like normal MEV “price improvement” unless modeled)

---

### (B) **Treasury buybacks are sandwichable**
`KerneTreasury` does Aerodrome swaps with slippage limits. Any public buyback tx can be:
- sandwiched by moving price against the treasury,
- treasury buys at worse price,
- attacker back-runs to restore.

Your bot has a “private submitter” (`bot/mev_protection.py`) but:
- it’s optional / best-effort,
- uses endpoints that are not guaranteed private for Base,
- any manual/owner-triggered buyback is likely public.

**Feasibility:** **Easy** (standard MEV)  
**Expected profit:** **Low → Medium per swap**, but persistent  
**Required capital:** **Medium** (needs inventory / ability to move pool price)  
**Detection difficulty:** **Easy** (classic sandwich patterns)

---

### (C) **PSM swaps are sandwichable (if routed through DEXs / virtual peg mode)**
If `virtualPegEnabled` or any swap path touches DEX liquidity, MEV applies.

**Feasibility:** **Medium**  
**Expected profit:** **Low → Medium**  
**Required capital:** **Medium**  
**Detection difficulty:** **Medium**

---

# 3) Oracle Manipulation (off-chain asset reporting / yield oracle)
This is where Kerne’s *hybrid on-chain/off-chain accounting* creates unusually large economic attack surface.

## (A) **Off-chain assets & shadow yield are “admin-priced”**
You have at least three “soft oracle” knobs:
- `KerneVault.offChainAssets` / `l1Assets` / `hedgingReserve` (state variables shown; setters/events implied)
- `KerneLSTHook.shadowYield[vault]` updated by `STRATEGIST_ROLE`
- `KerneVerificationNode.latestAttestations[vault]` updated by authorized signers (threshold default = **1**)

If `KerneVault.totalAssets()` includes any of these values (very likely), then **share price becomes a governance/oracle output**.

### Exploit pattern: “mark up assets → extract against inflated NAV”
If an attacker can influence these feeds (key compromise, malicious role holder, message spoofing):
1. Inflate reported off-chain assets / shadow yield
2. Use inflated share price to:
   - mint kUSD against “overvalued” kLP collateral (via `kUSDMinter`)
   - drain PSM stables by swapping kUSD for USDC/USDT 1:1
   - or simply sell/redeem shares at an unfair rate (depending on actual redeem mechanics/liquidity)
3. Let reporting revert to reality later; protocol eats insolvency/bad debt.

**Feasibility:**  
- External attacker: **Hard** (requires signer/strategist compromise or cross-chain spoof)  
- Insider/role-holder: **Easy**  
**Expected profit:** **Very High** (bounded by PSM reserves + vault buffer + any external liquidity Kerne controls)  
**Required capital:** **Low** (if you can “print” solvency)  
**Detection difficulty:** **Medium** (events exist, but the fraud is “authorized”; detecting *false* off-chain reports is hard)

---

## (B) **KerneVerificationNode signature design risks**
Visible facts:
- `threshold = 1` by default.
- Signed message includes `block.chainid`, `address(this)`, vault, values, timestamp.
- Only enforces `block.timestamp - timestamp < 1 hours`.

**Economic implication:** single compromised signer can rewrite solvency optics for 1 hour windows repeatedly.

**Feasibility:** **Medium** (key compromise happens; also insider)  
**Expected profit:** **Very High**  
**Required capital:** **Low**  
**Detection difficulty:** **Hard** (signatures validate; only off-chain reconciliation catches it)

---

## (C) **Yield Oracle (`KerneYieldOracle`) is not price oracle, but can be gamed by privileged updaters**
`updateYield()` reads `v.convertToAssets(1e18)` and enforces max deviation bps from last observation. This is updater-gated, so main risk is:
- malicious/compromised updater set can “stair-step” the price up within 5% bounds each update and manufacture high TWAY.

This becomes economically relevant if:
- TWAY gates minting/leverage parameters,
- TWAY is advertised to drive deposits (reflexive inflows),
- TWAY is used in other contracts for limits (not shown).

**Feasibility:** **Easy (insider)** / **Hard (external)**  
**Expected profit:** **Medium → High** (mostly indirect unless TWAY is used on-chain for issuance)  
**Required capital:** **Low**  
**Detection difficulty:** **Medium**

---

## (D) Frontend/server “oracles” (Binance, Hyperliquid, Bybit, Lido APIs)
These are not on-chain, but they can be used to:
- mislead users about APY/solvency,
- coordinate bank-run timing,
- obscure insolvency.

Also `/api/stats` trusts `process.env.RPC_URL`. A malicious RPC can report manipulated `totalAssets()` off-chain to UI.

**Feasibility:** **Easy** (traffic manipulation / RPC poisoning / upstream outage)  
**Expected profit:** **Indirect** (social engineering deposits/withdrawals)  
**Required capital:** **Low**  
**Detection difficulty:** **Hard** (silent catches + fallback fake data makes monitoring ambiguous)

---

# 4) Governance / Role Attacks (STRATEGIST, SOLVER, ADMIN extraction)
Kerne has **many value-moving roles** across:
- Vault (strategist, pauser, admin)
- Treasury (owner)
- InsuranceFund (manager/authorized)
- PSM (admin/manager/arbitrageur)
- Arbitrage executors (solver)
- Verification (verifier/admin)
- OFTs (owner)

### (A) STRATEGIST: “authorized misreporting” + “authorized sweeping”
`KerneVault` includes:
- `exchangeDepositAddress` immutable
- events like `FundsSwept(...)` (implied sweep function)
- offChainAssets/l1Assets/hedgingReserve reporting

A strategist with sweep + reporting ability can:
- sweep on-chain assets off-chain,
- keep `offChainAssets` reported high,
- users mint/redeem based on fake NAV until withdrawal failures.

**Feasibility:** **Easy (insider)**  
**Expected profit:** **Very High**  
**Required capital:** **None**  
**Detection difficulty:** **Hard** (looks like normal ops until withdrawals fail)

---

### (B) SOLVER roles on execution engines can exfiltrate via “allowed target” / aggregator call data
Even with whitelists (`KerneArbExecutor.allowedTargets`), solver systems are structurally extractive:
- they control routing, slippage, and profit accounting,
- they can trade against protocol flows (toxic flow / internalization),
- they can intentionally route through pools they manipulate.

`KerneIntentExecutor/V2` is especially sensitive: it calls external routers with `aggregatorData`. In V2, there is a `target` parameter (user-supplied via solver), and no shown whitelist in the snippet.

**Feasibility:** **Easy (insider/solver)**  
**Expected profit:** **High** (continuous leakage)  
**Required capital:** **Medium** (inventory/MEV)  
**Detection difficulty:** **Hard** (looks like normal routing)

---

### (C) ADMIN / Owner: OFT mint/burn is absolute power
`KerneOFT` and `KerneOFTV2` expose `mint()`/`burn()` to `onlyOwner`. If the owner is an EOA or weak multisig:
- total supply integrity is not “bridge-enforced”; it’s admin-enforced.
- cross-chain “double spend” becomes “owner mints anywhere”.

**Feasibility:** **Easy (if owner compromised)**  
**Expected profit:** **Very High**  
**Required capital:** **None**  
**Detection difficulty:** **Easy** on-chain, but hard to respond to across chains

---

# 5) Liquidity Attacks (drain liquid buffer / block withdrawals)
## (A) Bank-run amplifier: withdraw cooldown + off-chain deployment
`KerneVault` has `withdrawalCooldown = 7 days` and a queue (`withdrawalRequests`). That means:
- **instant liquidity is intentionally limited**.
- if a large fraction of assets are off-chain, the on-chain buffer is small.

### Attack: “drain buffer then force failed claims / secondary market discount”
Attacker strategy:
1. Monitor buffer (on-chain asset balance).
2. Redeem/withdraw early to drain liquid portion.
3. Everyone else becomes stuck in cooldown queue and/or receives delayed fulfillment.
4. Attacker profits by:
   - shorting any kLP/kUSD peg expectations,
   - buying distressed claims OTC (if a market exists),
   - arbitraging kUSD depeg via PSM if it breaks.

**Feasibility:** **Medium** (needs meaningful share ownership)  
**Expected profit:** **Medium → High** (if it triggers kUSD depeg / forced unwind)  
**Required capital:** **High** (needs enough shares to drain buffer)  
**Detection difficulty:** **Easy** (buffer depletion is visible)

---

## (B) Griefing: flash-loan temporarily drains buffer to make withdrawals revert
If withdraw path requires liquid balance at execution time, attacker can:
- flash borrow the asset from the vault right before a victim withdraw executes (MEV),
- victim tx reverts due to insufficient liquidity,
- attacker repays end of tx.

This is mostly grief unless combined with MEV bribes / liquidation triggers.

**Feasibility:** **Easy** (if flash lending exists and no “liquidity locked” accounting)  
**Expected profit:** **Low** (mostly DoS/extortion)  
**Required capital:** **Low**  
**Detection difficulty:** **Medium**

---

# 6) Cross-Chain Attacks (LayerZero OFT + message replay/double spend)
There are two distinct cross-chain surfaces:

## (A) **OFT bridge correctness (kUSD/KERNE as OFT)**
LayerZero OFT is generally robust, but common failures are *configuration*:
- wrong trusted peers / endpoints,
- allowing messages from untrusted origin,
- delegate/owner compromise.

Given your OFTs also have `onlyOwner mint/burn`, the largest risk is **key compromise / mismanagement**, not LZ core bugs.

**Feasibility:** **Hard** (protocol-level LZ exploit) / **Medium** (misconfig) / **Easy** (owner compromise)  
**Expected profit:** **Very High**  
**Required capital:** **None**  
**Detection difficulty:** **Medium** (bridging events are visible; root cause attribution is harder)

---

## (B) **VerificationNode cross-chain attestation sync (OApp)**
`KerneVerificationNode.syncAttestation()` sends payload cross-chain. `_lzReceive()` is truncated.

If `_lzReceive()` does not strictly validate:
- `Origin.srcEid`
- `Origin.sender` (trusted remote)
- replay protection / GUID uniqueness (usually handled, but apps can still make mistakes)

then an attacker may inject forged attestations **without owning a signer key**, via cross-chain message spoofing.

**Feasibility:** **Theoretical → Medium** (depends on `_lzReceive` implementation + OApp config)  
**Expected profit:** **High → Very High** (if attestations influence solvency gates or `totalAssets`)  
**Required capital:** **Low → Medium** (cross-chain fees)  
**Detection difficulty:** **Hard** (messages look like legitimate LZ deliveries)

---

# 7) Insurance Fund Attacks
`KerneInsuranceFund`:
- `claim()` allows authorized callers to transfer up to `maxClaimPercentage` of current balance, per hour per caller.
- `MANAGER_ROLE` can grant/revoke `AUTHORIZED_ROLE` and set maxClaimPercentage.

### (A) Privileged drain (manager/admin compromise)
If attacker gets `MANAGER_ROLE` or `DEFAULT_ADMIN_ROLE`:
- set `maxClaimPercentage` to 10000,
- authorize attacker address,
- drain entire fund in 1–2 calls (cooldown is per caller; admin can use multiple authorized addresses or just set to 100% and take once).

**Feasibility:** **Easy (insider/key compromise)**  
**Expected profit:** **Very High** (entire insurance balance)  
**Required capital:** **None**  
**Detection difficulty:** **Easy** (transfers on-chain), but too late

### (B) Economic manipulation: route more “profits” to insurance then drain
Arb bots split profit to insurance (e.g., 20%). A compromised solver/treasury could “over-route” to insurance to create a honeypot, then drain via authorization.

**Feasibility:** **Medium**  
**Expected profit:** **High**  
**Required capital:** **Low**  
**Detection difficulty:** **Hard** (looks like healthy funding until drain)

---

# 8) Tokenomics Exploits (KERNE staking + airdrop)
## (A) **KerneStaking has no minimum lock; “ve-style” can be bypassed**
In `stake(amount, duration)`:
- `lockEnd = block.timestamp + duration`
- **no requirement that `duration > 0`**
So attacker can stake with `duration = 0`, then:
- if they can position around `distributeRewards()` (called by `DISTRIBUTOR_ROLE`),
- capture rewards with essentially no lock (stake just before, withdraw after).

This is a classic “liquidity sniping” of reward distributions.

**Feasibility:** **Easy**  
**Expected profit:** **Medium** (bounded by reward size per distribution)  
**Required capital:** **Medium → High** (need large stake fraction briefly)  
**Detection difficulty:** **Easy** (stake duration 0 stands out)

Mitigation is simple: enforce min duration or implement time-weighted rewards / withdrawal penalty.

---

## (B) Airdrop “Prisoner’s Dilemma” sybil/game theory farming
Even with a Merkle root, a user with multiple eligible allocations can:
- claim some allocations as MERCENARY to build `penaltyPool`,
- claim others as LOYALIST to recapture a large fraction of that penalty as bonus.

This doesn’t mint extra tokens out of thin air, but it **optimizes payout timing and lock exposure**, potentially undermining intended distribution goals.

**Feasibility:** **Easy** (if attacker has multiple allocations)  
**Expected profit:** **Low → Medium** (redistribution within fixed pool)  
**Required capital:** **None**  
**Detection difficulty:** **Hard** (just looks like “normal choices”)

---

# 9) Delta-Neutral Strategy Risks (intentional triggering)
This is mostly off-chain, but economically critical.

## (A) Deliberate liquidation of Kerne’s shorts (CEX/L1 venues)
If Kerne runs large short perps positions, an attacker with enough capital can:
- engineer rapid spot/perp basis moves,
- push mark prices toward liquidation bands on one venue (especially if margin fragmented),
- trigger forced deleveraging at bad prices.

Once off-chain equity drops, Kerne becomes insolvent relative to on-chain liabilities:
- vault pauses,
- withdrawals delayed,
- kUSD may depeg,
- PSM may halt via `minSolvencyThreshold` checks (but only if solvency oracle is honest and timely).

**Feasibility:** **Hard** (requires real market impact, but you asked to assume unlimited capital)  
**Expected profit:** **Very High** via:
- shorting KERNE/kUSD,
- buying distressed claims,
- arbitraging PSM depeg,
- capturing liquidation cascades across venues  
**Required capital:** **Very High**  
**Detection difficulty:** **Medium** (market event visible; attribution hard)

## (B) Trigger via oracle/attestation latency (“solvency cliff”)
If `getSolvencyRatio()` depends on attestations that can go stale (and bots pause), attacker can:
- time bank-run around known reporting windows,
- force protocol to operate briefly on stale solvency then freeze.

**Feasibility:** **Medium**  
**Expected profit:** **Medium → High** (timing-based extraction)  
**Required capital:** **Medium**  
**Detection difficulty:** **Hard**

---

# 10) Composability Risks (Vault ↔ Minter ↔ PSM ↔ Insurance interactions)
This is where “small” mispricings become total drains.

## (A) “Mint kUSD against mispriced kLP → drain PSM stables”
**Systemic drain path:**
1. Obtain kLP shares cheaply (via vault flash-loan share inflation, or via NAV inflation if privileged oracle is compromised).
2. Use kUSDMinter to mint kUSD at 150% ratio *based on manipulated valuation*.
3. Swap kUSD to USDC/USDT in PSM 1:1.
4. Exit with real stables; leave protocol with undercollateralized debt.

**Feasibility:**  
- **Easy** if (a) vault share inflation exists and can be turned into “extra collateral”, or (b) off-chain valuation can be inflated  
- otherwise **Medium**  
**Expected profit:** **Very High** (bounded by PSM reserves + any other stable liquidity)  
**Required capital:** **Low → Medium** (mostly flash-assisted)  
**Detection difficulty:** **Hard** (looks like normal mint + swap until too late)

## (B) Solvency gating can be bypassed if oracle is attacker-controlled
Multiple modules rely on:
- `vault.staticcall("getSolvencyRatio()")` (PSM, ArbExecutor)
If `getSolvencyRatio()` can be influenced by:
- verification node spoofing,
- strategist marking,
- stale-but-accepted attestations,

then circuit breakers become **decorative**.

**Feasibility:** **Medium**  
**Expected profit:** **High**  
**Required capital:** **Low**  
**Detection difficulty:** **Hard**

## (C) Insurance fund as “final buffer” creates moral hazard + extraction routes
If insurance pays out to vault during insolvency (`socializeLoss`), an attacker who front-runs the payout can:
- redeem/withdraw immediately after insurance injection,
- effectively “snipe” the recapitalization.

This is a known pattern: recapitalization events are MEV targets.

**Feasibility:** **Medium**  
**Expected profit:** **Medium → High**  
**Required capital:** **Medium**  
**Detection difficulty:** **Medium**

---

# Recommended “attacker simulation” checklist (what I would test first)
1) **Vault flash-loan share inflation PoC**
   - Borrow X via `flashLoan`
   - In callback: `deposit(y)` then repay X
   - After tx: redeem minted shares and measure profit vs y
2) **kUSDMinter composition**
   - Use the inflated shares as collateral; attempt to mint kUSD and exit via PSM
3) **Staking duration=0 reward snipe**
   - Stake huge with duration 0, wait for distributor tx, withdraw immediately
4) **Cross-chain forged attestation**
   - Review `_lzReceive` validation and OApp peer config; attempt replay/spoof in test
5) **MEV on treasury buyback**
   - Simulate Aerodrome pool sandwich given slippageBps and MAX_SLIPPAGE behavior

---

If you share the missing parts of `KerneVault.totalAssets()`, its flash-loan implementation, and the remaining `KUSDPSM` + `kUSDMinter` functions (mint/burn/fold/liquidate), I can turn the above into **concrete exploit sequences with exact state transitions** and compute **profit bounds** under realistic pool/liquidity assumptions.

---

## Final Report

# Kerne Protocol — Penetration Testing Report  
**Date:** 2026-02-09  
**Tester:** Shannon AI (Gemini 3 Flash) via Kerne Security Pipeline  

---

## Executive Summary

Testing identified multiple **critical smart contract access-control and initialization vulnerabilities** that could enable **immediate loss of funds, permanent takeover of core contracts, or unauthorized movement of protocol reserves**. The most severe issues are (1) **vault initialization takeover** (anyone can initialize an uninitialized KerneVault and obtain privileged roles) and (2) **unauthenticated flash-loan callback handling** in the intent execution engine, which can allow arbitrary callers to trigger token transfers and external calls.

In addition, we confirmed a **broken authorization check** in the insurance fund that allows any external party to force insurance transfers to an authorized vault. While this may not always yield direct profit for the attacker, it can **deplete insurance reserves, manipulate vault accounting/share value dynamics, and destabilize protocol risk management**.

Overall, Kerne’s current security posture is **high risk for production TVL** until the listed critical issues are remediated and re-reviewed. Several issues are systemic (initializer design, callback authentication patterns, and trust boundaries between “reporting” values and ERC-4626 accounting), increasing the likelihood of multi-step exploits once attackers gain a single foothold.

---

## Findings Summary Table

| Severity | Category | Title |
|---:|---|---|
| **CRITICAL** | Smart Contract / Access Control | KerneVault can be initialized by anyone (role takeover) |
| **CRITICAL** | Smart Contract / Access Control | Intent Executor V2 `onFlashLoan()` is unauthenticated (direct drain / arbitrary call) |
| **CRITICAL** | Smart Contract / Logic / Accounting | KUSD PSM 1:1 swaps ignore token decimals (catastrophic mispricing) |
| **HIGH** | Smart Contract / Access Control | Insurance Fund `socializeLoss()` checks role on parameter, not caller (forced payouts) |
| **HIGH** | Smart Contract / Privilege / Governance | KerneVault `_initialize()` grants `DEFAULT_ADMIN_ROLE` to `msg.sender` (persistent backdoor admin) |
| **HIGH** | Smart Contract / Privilege / Governance | KerneVault strategist is set to `msg.sender` during initialization (unintended strategist control) |
| **MEDIUM** | Smart Contract / Oracle Handling | PSM Chainlink price normalization can underflow & missing round validity checks |
| **MEDIUM** | Smart Contract / Access Control | Arb Executor flash-loan callback lacks lender authentication |
| **MEDIUM** | Smart Contract / Logic / Units | kUSDMinter flash leverage mixes units (asset vs kUSD) and assumes 1:1 repayment |
| **MEDIUM** | Smart Contract / Availability | Vault `checkAndPause()` is publicly callable and can be griefed via dependency failures |

> Out of scope / not reported as vulnerabilities: No exploitable SQLi/NoSQLi/command injection/XSS/SSRF were proven from the provided Next.js and bot snippets; those analyses were retained as **assessment notes** but do not appear as findings.

---

## Detailed Findings

### 1) CRITICAL — KerneVault can be initialized by anyone (role takeover)

**Affected component:** `src/KerneVault.sol`  
**Location:** `initialize(...)` — authorization condition permitting non-factory initialization when `factory == address(0)`  

#### Description
The vault initialization guard allows **any external account** to call `initialize()` when `factory` is unset (zero address), due to logic equivalent to:

```solidity
require(factory == address(0) || msg.sender == factory, "Only factory can initialize");
```

In the provided code context, `factory` is declared but not shown being set prior to initialization. With `factory == address(0)` and `founder == address(0)` (used as an initialization sentinel), the contract becomes **publicly initializable**.

#### Impact
- Full administrative takeover of the vault instance.
- Ability to assign privileged roles (admin/strategist/pauser), modify critical accounting inputs, and potentially execute fund movement functions (e.g., `sweepToExchange(...)` if present/enabled).
- If exploited on a vault with TVL, this becomes **direct theft and/or permanent DoS**.

#### Exploit scenario (on-chain)
1. Attacker identifies a newly deployed/uninitialized vault (or front-runs the intended initializer).
2. Attacker calls `initialize(...)` first, setting themselves as privileged operator.
3. Attacker exercises admin-only functionality to extract funds, change configuration, or lock the system.

#### Proof of Concept (Foundry `cast`)
```bash
cast send $VAULT \
  "initialize(address,string,string,address,address,uint256,uint256,bool)" \
  0x0000000000000000000000000000000000000000 \
  "HackedVault" "HVLT" \
  $ATTACKER_ADDRESS \
  $ATTACKER_ADDRESS \
  0 \
  2000 \
  false \
  --private-key $ATTACKER_KEY
```

#### Remediation
- Enforce strict factory-only initialization:
  ```solidity
  require(msg.sender == factory, "Only factory can initialize");
  ```
- Adopt OpenZeppelin `Initializable` and disable initializers on implementation contracts (`_disableInitializers()`).
- Ensure clones/instances have `factory` set in a way that cannot be bypassed (e.g., immutable args pattern, or factory set at construction/clone creation in the same atomic flow).

---

### 2) CRITICAL — Intent Executor V2 `onFlashLoan()` is unauthenticated (direct drain / arbitrary call)

**Affected component:** `src/KerneIntentExecutorV2.sol`  
**Location:** `onFlashLoan(...)` — missing lender authentication; executes arbitrary external call and transfers tokens  

#### Description
The ERC-3156 flash loan callback `onFlashLoan()` is `external` and must authenticate the **lender** (`msg.sender`) and bind callback parameters to the originally initiated flash loan. In the provided logic:
- There is **no** `require(msg.sender == approvedLender)` (or equivalent allowlist).
- The function performs `target.call(aggregatorData)` without a target allowlist.
- It transfers tokens out (`safeTransfer(user, amountOut)`) based on decoded callback data.

This allows **any external attacker** to call `onFlashLoan()` directly and attempt to:
- Transfer out any token balances held by the executor
- Trigger arbitrary downstream calls
- Potentially set approvals toward attacker-controlled addresses (depending on allowance patterns)

#### Impact
- **Direct theft** of any ERC20 balances held by the executor contract.
- Arbitrary call execution as the executor contract, enabling loss amplification (approvals, interacting with other contracts, griefing).
- Severe systemic risk if the executor is expected to custody funds during normal operation.

#### Exploit scenario (direct external call)
1. Attacker checks executor token balances (airdrops, stuck funds, operational balances).
2. Attacker calls `onFlashLoan(...)` directly with crafted `data` that sets:
   - `user = attacker`
   - `tokenOut = token held by executor`
   - `amountOut = executor token balance`
   - `target = attacker-controlled contract`
3. Callback transfers tokens to attacker.

#### Minimal PoC (Solidity sketch)
```solidity
contract TargetMock { fallback() external payable {} }

function drain(KerneIntentExecutorV2 ex, IERC20 token) external {
    TargetMock t = new TargetMock();
    uint bal = token.balanceOf(address(ex));

    bytes memory data = abi.encode(
        address(0), bal, msg.sender, address(t), bytes(""), msg.sender, uint8(0)
    );

    // Direct call — not from a real lender
    ex.onFlashLoan(address(ex), address(token), 1, 0, data);
}
```

#### Remediation
- Add lender allowlisting and enforce it:
  ```solidity
  require(approvedLenders[msg.sender], "Unapproved lender");
  ```
- Bind callback to a stored expected request (nonce/hash), and clear it after use.
- Add a strict allowlist for `target`, and preferably restrict allowed selectors or use known aggregator interfaces rather than arbitrary `call`.

---

### 3) CRITICAL — KUSD PSM 1:1 swaps ignore token decimals (catastrophic mispricing)

**Affected component:** `src/KUSDPSM.sol`  
**Location:** `swapStableForKUSD()` and `swapKUSDForStable()` — uses `amount` without decimals normalization  

#### Description
The PSM implements “1:1” swaps but does not normalize between token decimal formats. Because stablecoins commonly use 6 decimals (e.g., USDC/USDT) while many protocol tokens use 18, using the raw `amount` on both sides can misprice swaps by orders of magnitude.

#### Impact
- Catastrophic mispricing enabling protocol insolvency, user loss, or immediate reserve drain depending on configured token decimals and swap direction.
- Can break peg mechanisms and any downstream assumptions about kUSD supply/backing.

#### Exploit scenario (example with 6-decimal stable vs 18-decimal kUSD)
- Swapping `1 USDC` (`1e6`) for `1e6` units of a token with 18 decimals results in `0.000001` token units, or conversely could overpay in the other direction depending on implementation specifics—either direction can be fatal.

#### Remediation
- Normalize amounts using `IERC20Metadata.decimals()`:
  ```solidity
  uint8 stableDec = IERC20Metadata(stable).decimals();
  uint8 kusdDec   = IERC20Metadata(address(kUSD)).decimals();

  uint256 kusdAmount = amount * 10**kusdDec / 10**stableDec;
  ```
- Apply the same normalization consistently to:
  - Fees
  - Caps/exposure tracking
  - Accounting events

---

### 4) HIGH — Insurance Fund `socializeLoss()` checks role on parameter, not caller (forced payouts)

**Affected component:** `src/KerneInsuranceFund.sol`  
**Location:** `socializeLoss(address vault, uint256 amount)`  

#### Description
Authorization is checked against the **function parameter** `vault` rather than `msg.sender`:

```solidity
require(hasRole(AUTHORIZED_ROLE, vault), "Vault not authorized");
```

As a result, **any external attacker** can call `socializeLoss()` and pass a vault address that has `AUTHORIZED_ROLE`, forcing the insurance fund to transfer assets to that vault.

#### Impact
- Untrusted third parties can **deplete insurance reserves** by repeatedly forcing transfers.
- Can manipulate protocol accounting and vault share value dynamics.
- Enables griefing and destabilizes incident-response controls (insurance payout should be controlled and auditable).

#### Exploit scenario (forced payout then share capture)
1. Attacker acquires vault shares (small deposit).
2. Attacker forces insurance payout into the vault via `socializeLoss(vault, amount)`.
3. Attacker redeems shares after the vault value increases, capturing a pro-rata share of the payout.

#### Proof of Concept (`cast`)
```bash
cast send $INSURANCE "socializeLoss(address,uint256)" $VAULT 1000000000000000000000000 --private-key $ATTACKER_KEY
```

#### Remediation
- Validate the caller:
  ```solidity
  require(hasRole(AUTHORIZED_ROLE, msg.sender), "Not authorized");
  ```
- Consider vault-self-only design: remove `vault` parameter and use `msg.sender` as the vault recipient.
- Add per-vault and/or global rate limits, plus eventing for monitoring/alerting.

---

### 5) HIGH — KerneVault `_initialize()` grants `DEFAULT_ADMIN_ROLE` to `msg.sender` (persistent backdoor admin)

**Affected component:** `src/KerneVault.sol`  
**Location:** `_initialize(...)` — grants admin to both `admin_` and `msg.sender`  

#### Description
The vault grants `DEFAULT_ADMIN_ROLE` to `msg.sender` during initialization:

```solidity
_grantRole(DEFAULT_ADMIN_ROLE, admin_);
_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
```

If initialization is performed by a factory, the factory becomes a permanent admin across deployed vaults. If an attacker initializes a vault (see Finding #1), they become admin regardless of what `admin_` is set to.

#### Impact
- Persistent, non-obvious privileged access path (supply chain / factory compromise becomes systemic compromise).
- Increases blast radius: compromise of the factory (or initializer) compromises every vault.

#### Remediation
- Remove the `msg.sender` admin grant.
- If temporary deployer permissions are required, grant a narrowly scoped role and revoke it at the end of initialization.

---

### 6) HIGH — KerneVault strategist is set to `msg.sender` during initialization (unintended strategist control)

**Affected component:** `src/KerneVault.sol`  
**Location:** `initialize(...)` passes `msg.sender` as strategist (per provided analysis)  

#### Description
Strategist permissions are assigned to the initialization caller rather than an explicit strategist address parameter.

#### Impact
- Factory or attacker becomes strategist.
- Strategist can typically change key reporting variables (e.g., off-chain assets / hedging reserve / projected APY), undermining solvency metrics and user trust.

#### Remediation
- Add an explicit `strategist_` argument to the initializer and enforce it.
- Apply least-privilege and role separation (admin ≠ strategist).

---

### 7) MEDIUM — PSM Chainlink normalization can underflow & missing round validity checks

**Affected component:** `src/KUSDPSM.sol`  
**Location:** `_checkDepeg()` price normalization  

#### Description
Normalization logic uses `10 ** (18 - decimals)` which underflows if `decimals > 18` and does not include best-practice checks like `answeredInRound`.

#### Impact
- Potential swap DoS if oracle config uses unexpected decimals.
- Increased risk of accepting invalid/stale oracle results.

#### Remediation
- Normalize safely for both `decimals < 18` and `decimals > 18`.
- Validate `roundId`, `answeredInRound`, and staleness.

---

### 8) MEDIUM — Arb Executor flash-loan callback lacks lender authentication

**Affected component:** `src/KerneArbExecutor.sol`  
**Location:** `onFlashLoan(...)` — checks `initiator` but not lender (`msg.sender`)  

#### Description
`initiator` checks alone are insufficient; the callback should authenticate the lender to prevent direct external calls to `onFlashLoan`.

#### Impact
- Potential for unexpected execution paths, approvals, and router interactions (even if profit checks reduce direct theft likelihood).
- Increased attack surface and audit complexity.

#### Remediation
- Store the expected lender during flash-loan initiation and verify `msg.sender`.
- Or maintain an approved lender allowlist.

---

### 9) MEDIUM — kUSDMinter flash leverage mixes units (asset vs kUSD) and assumes 1:1 repayment

**Affected component:** `src/kUSDMinter.sol`  
**Location:** `onFlashLoan()` (flash leverage flow) — treats `amountToRepay` as both asset-denominated and kUSD-denominated  

#### Description
The flow mints kUSD in an amount derived from asset repayment requirements without robust pricing/decimals conversion, creating unit inconsistency. This is unsafe unless the vault asset is a strictly 1:1 stable with matching decimals and minimal slippage—assumptions that commonly break in real deployments.

#### Impact
- Potential under/over-collateralization.
- Unexpected reverts or economic mis-accounting under non-ideal conditions.
- Attackers may exploit inconsistencies when combined with routing control or oracle weaknesses.

#### Remediation
- Denominate debt strictly in kUSD, collateral in asset, and use an oracle/quote mechanism for conversion with slippage controls.
- If the design intent is “stable-only,” enforce stable-only assets at the contract level and match decimals.

---

### 10) MEDIUM — Vault `checkAndPause()` is publicly callable and can be griefed via dependency failures

**Affected component:** `src/KerneVault.sol`  
**Location:** `checkAndPause()` triggers solvency evaluation and potential pause behavior  

#### Description
A public function that updates pause/solvency state can be abused to create repeated checks and state transitions—particularly if solvency depends on external contracts (e.g., `trustAnchor`, `verificationNode`) that can fail or become temporarily unavailable.

#### Impact
- Operational DoS / griefing (forcing repeated evaluations, possible pausing depending on grace logic).
- Increased fragility during upstream incidents.

#### Remediation
- Gate pause-triggering transitions to a guardian role, or ensure oracle failures do not change insolvency state (“unknown” instead of “insolvent”).
- Add rate limiting and robust failure handling.

---

## Remediation Priority Matrix

| Priority | Timeframe | Findings | Rationale |
|---|---:|---|---|
| **P0 (Immediate)** | 0–7 days | **#1 Vault init takeover**, **#2 IntentExecutorV2 onFlashLoan unauth**, **#3 PSM decimals** | Direct fund loss / contract takeover risk; exploitable without privileged access (or with minimal preconditions). |
| **P1 (Urgent)** | 8–30 days | **#4 Insurance socializeLoss auth bug**, **#5 Backdoor admin**, **#6 Strategist = msg.sender** | High systemic risk and privilege boundary flaws; reduces blast radius and prevents forced reserve movement. |
| **P2 (Planned)** | 31–90 days | **#7 Oracle normalization hardening**, **#8 ArbExecutor lender auth**, **#9 kUSDMinter unit consistency**, **#10 checkAndPause griefing** | Important correctness and resilience improvements; reduces DoS/economic edge-case risk and improves operational safety. |

---

## Overall Security Posture Assessment

### Security score (0–100): **35 / 100**

**Justification:**  
- Presence of multiple **Critical** issues enabling **role takeover** and **unauthenticated callback execution** significantly lowers the score.  
- Several findings indicate **systemic patterns** (initializer safety, callback authentication, decimals/unit normalization) that tend to produce repeat vulnerabilities across modules if not addressed holistically.  
- Web/API surfaces reviewed in the provided scope did **not** yield exploitable injection/XSS/SSRF; however, the protocol’s risk is dominated by **smart contract correctness and access control**, which currently require urgent remediation.

### Posture highlights
- **Strengths observed:** No proven web injection, XSS, SSRF, or secret leakage in the provided frontend/API snippets; some allowlisting patterns exist (e.g., symbol validation).
- **Key weaknesses:** Access control subject confusion (`vault` parameter vs `msg.sender`), unsafe initialization patterns, missing authentication on critical callback entrypoints, and high-impact accounting/decimals correctness issues.

### Recommended next steps (after fixes)
1. **Re-audit** after P0/P1 fixes with full source for all referenced but missing routes/contracts.  
2. Add **invariant/unit tests** for:
   - initialization immutability
   - flash callback authentication
   - decimals normalization across all swap/mint paths  
3. Implement a **threat-model driven role design**: explicit trust boundaries, least privilege, and removal of implicit factory/deployer backdoors.  

--- 

If you want, I can also deliver a “verification pack” for engineering: regression test cases (Foundry) for each fixed issue, plus deployment-time assertions (e.g., factory set, initializers disabled, approved lenders configured) to prevent reintroduction.
