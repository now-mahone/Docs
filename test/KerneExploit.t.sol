// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import { Test, console } from "forge-std/Test.sol";
import { KerneVault } from "../src/KerneVault.sol";
import { kUSD } from "../src/kUSD.sol";
import { kUSDMinter } from "../src/kUSDMinter.sol";
import { KerneVaultFactory } from "../src/KerneVaultFactory.sol";
import { KerneInsuranceFund } from "../src/KerneInsuranceFund.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract MockERC20 is ERC20 {
    constructor() ERC20("Mock WETH", "WETH") { }

    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

contract KerneExploitTest is Test {
    KerneVault public vault;
    KerneVault public implementation;
    KerneVaultFactory public factory;
    kUSD public kusd;
    kUSDMinter public minter;
    MockERC20 public asset;
    KerneInsuranceFund public insuranceFund;

    address public admin = address(0x1);
    address public strategist = address(0x2);
    address public user = address(0x3);
    address public attacker = address(0x4);

    function setUp() public {
        asset = new MockERC20();

        // Deploy Implementation
        implementation = new KerneVault(asset, "Kerne Vault Token", "kLP", address(this), address(this), address(0));

        // Deploy Factory
        factory = new KerneVaultFactory(address(implementation));

        // Deploy Vault via Factory
        address vaultAddr = factory.deployVault(
            address(asset), "Kerne Vault Token", "kLP", admin, 1000, false, 0, KerneVaultFactory.VaultTier.BASIC
        );

        vault = KerneVault(vaultAddr);

        // Deploy kUSD
        kusd = new kUSD(admin);

        // Deploy Minter
        minter = new kUSDMinter(address(kusd), address(vault), admin);

        // Deploy Insurance Fund
        insuranceFund = new KerneInsuranceFund(address(asset));

        // Setup Roles
        vm.startPrank(admin);
        kusd.grantRole(kusd.MINTER_ROLE(), address(minter));
        vault.setInsuranceFund(address(insuranceFund));
        vm.stopPrank();

        vm.startPrank(insuranceFund.owner());
        insuranceFund.setAuthorization(address(vault), true);
        vm.stopPrank();

        // Fund user
        asset.mint(user, 100 ether);
        vm.startPrank(user);
        asset.approve(address(vault), 100 ether);
        vault.deposit(100 ether, user);
        vm.stopPrank();
    }

    // 1. ERC-4626 Inflation Attack (Mitigated by Dead Shares)
    function testInflationAttackMitigated() public {
        KerneVault newVault = new KerneVault(asset, "New Vault", "nLP", admin, strategist, address(0));

        vm.startPrank(attacker);
        asset.mint(attacker, 100 ether);
        asset.approve(address(newVault), 100 ether);

        // Attacker deposits 1 wei
        newVault.deposit(1, attacker);

        // Attacker "donates" to inflate price
        asset.transfer(address(newVault), 10 ether);

        // User tries to deposit
        vm.startPrank(user);
        asset.mint(user, 5 ether);
        asset.approve(address(newVault), 5 ether);
        newVault.deposit(5 ether, user);

        // With dead shares mitigation, user DOES get shares (attack is mitigated!)
        // The user gets ~1000 shares because of the initial dead share seed
        assertGt(newVault.balanceOf(user), 0);
        vm.stopPrank();
    }

    // 4. Oracle Manipulation (kLP Price) - Tests that manipulated kLP price affects minting
    function testPriceManipulationExploit() public {
        uint256 initialPrice = minter.getKLPPrice();

        // Note: For factory-deployed vaults, the factory is the strategist
        vm.prank(address(factory));
        vault.updateOffChainAssets(1000 ether);

        uint256 manipulatedPrice = minter.getKLPPrice();
        assertGt(manipulatedPrice, initialPrice);

        // User needs sufficient collateral balance to mint kUSD
        // The user already deposited 100 ETH into the vault in setUp
        // With the price manipulation, verify the price changed
        assertTrue(manipulatedPrice > initialPrice, "Price should be manipulated");
    }

    // 6. Unauthorized initialize call
    function testInitializeHijack() public {
        KerneVault clone = KerneVault(
            factory.deployVault(
                address(asset), "Clone", "CL", admin, 0, false, 0, KerneVaultFactory.VaultTier.BASIC
            )
        );

        // Attempt to re-initialize
        vm.expectRevert("Already initialized");
        clone.initialize(address(asset), "Hacked", "HK", attacker, attacker, 2000, 1000, false);
    }

    // 7. Access Control Bypass
    function testAccessControlBypass() public {
        vm.startPrank(attacker);
        vm.expectRevert();
        vault.updateOffChainAssets(1000 ether);

        vm.expectRevert();
        vault.sweepToExchange(1 ether);
        vm.stopPrank();
    }

    // 14. Insurance Fund Drain
    function testInsuranceFundDrain() public {
        asset.mint(address(insuranceFund), 10 ether);

        vm.startPrank(attacker);
        vm.expectRevert("Not authorized");
        insuranceFund.claim(attacker, 10 ether);
        vm.stopPrank();
    }

    // 16. Strategist Drain via captureFounderWealth
    function testStrategistDrainExploit() public {
        vm.startPrank(admin);
        vault.setFounder(attacker);
        vault.setPerformanceFee(2000); // 20%
        vm.stopPrank();

        // Note: For factory-deployed vaults, the factory is the strategist
        vm.prank(address(factory));
        vault.captureFounderWealth(100 ether);

        uint256 attackerBalance = asset.balanceOf(attacker);
        assertEq(attackerBalance, 20 ether);
    }

    // 17. Whitelisting Bypass
    function testWhitelistingBypass() public {
        vm.prank(admin);
        vault.setWhitelistEnabled(true);

        vm.startPrank(attacker);
        asset.mint(attacker, 1 ether);
        asset.approve(address(vault), 1 ether);
        vm.expectRevert("Not whitelisted or compliant");
        vault.deposit(1 ether, attacker);
        vm.stopPrank();
    }

    // 18. Pausable Bypass
    function testPausableBypass() public {
        vm.prank(admin);
        vault.pause();

        vm.startPrank(user);
        vm.expectRevert(abi.encodeWithSignature("EnforcedPause()"));
        vault.deposit(1 ether, user);
        vm.stopPrank();
    }
}
