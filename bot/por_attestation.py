import os
import json
import time
from web3 import Web3
from eth_account.messages import encode_defunct
from dotenv import load_dotenv
from loguru import logger
from exchange_manager import ExchangeManager

# Created: 2026-01-12
# Updated: 2026-01-13 (Automated Solvency Pulse)

class PoRAttestationBot:
    """
    Automated Proof of Reserve (PoR) Attestation Bot.
    Signs off-chain reserve data and publishes it for institutional transparency.
    """
    def __init__(self):
        load_dotenv()
        self.rpc_url = os.getenv("RPC_URL")
        self.private_key = os.getenv("PRIVATE_KEY")
        self.vault_address = os.getenv("VAULT_ADDRESS")
        self.verification_node_address = os.getenv("VERIFICATION_NODE_ADDRESS")
        
        if not all([self.rpc_url, self.private_key, self.vault_address]):
            logger.error("Missing environment variables for PoRAttestationBot.")
            raise ValueError("Missing RPC_URL, PRIVATE_KEY, or VAULT_ADDRESS")

        self.w3 = Web3(Web3.HTTPProvider(self.rpc_url))
        self.account = self.w3.eth.account.from_key(self.private_key)
        
        # Initialize ExchangeManager for Hyperliquid assets
        try:
            self.exchange = ExchangeManager()
        except Exception as e:
            logger.warning(f"Could not initialize ExchangeManager: {e}. Using 0 for off-chain assets.")
            self.exchange = None

        # Load Vault ABI for on-chain checks
        self.vault_abi = [
            {
                "inputs": [],
                "name": "totalSupply",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalAssets",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ]
        self.vault = self.w3.eth.contract(address=self.vault_address, abi=self.vault_abi)

    def get_solvency_metrics(self):
        """
        Calculates total assets, net delta, and off-chain equity.
        """
        on_chain_assets_wei = self.vault.functions.totalAssets().call()
        on_chain_assets = float(self.w3.from_wei(on_chain_assets_wei, 'ether'))
        
        off_chain_equity = 0
        short_size = 0
        if self.exchange:
            # Equity = Aggregate Equity across all exchanges
            off_chain_equity = self.exchange.get_total_equity()
            pos = self.exchange.get_aggregate_position("ETH")
            short_size = abs(pos["size"]) # Position size is negative for shorts
            
        net_delta = 0
        if on_chain_assets > 0:
            # Delta = abs(1 - ShortSize / OnChainAssets)
            net_delta = abs(1 - (short_size / on_chain_assets))
            
        return on_chain_assets, off_chain_equity, net_delta

    def generate_solvency_report(self):
        """
        Generates a detailed solvency report and saves it to docs/reports/.
        """
        on_chain, off_chain_equity, net_delta = self.get_solvency_metrics()
        total_assets = on_chain + off_chain_equity
        total_liabilities_wei = self.vault.functions.totalSupply().call()
        total_liabilities = float(self.w3.from_wei(total_liabilities_wei, 'ether'))
        
        is_solvent = total_assets >= total_liabilities and net_delta <= 0.05
        status = "SOLVENT" if is_solvent else "CRITICAL_RISK"
        
        if total_liabilities > 0:
            ratio_val = (total_assets / total_liabilities) * 100
            ratio_str = "{:,.2f}%".format(ratio_val)
        else:
            ratio_str = "1,000,000.00%+" if total_assets > 0 else "100.00%"

        report_path = os.path.join("docs", "reports", f"solvency_report_{time.strftime('%Y_%m_%d')}.md")
        os.makedirs(os.path.dirname(report_path), exist_ok=True)
        
        report_date = time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime())
        
        with open(report_path, "w") as f:
            f.write("# Kerne Institutional Solvency Report - {}\n\n".format(report_date))
            f.write("**Status:** {}\n\n".format(status))
            f.write("- **Total Assets:** {:.4f} ETH-equiv\n".format(total_assets))
            f.write("  - On-chain: {:.4f} ETH\n".format(on_chain))
            f.write("  - Off-chain Equity: {:.4f} ETH-equiv\n".format(off_chain_equity))
            f.write("- **Total Liabilities:** {:.4f} ETH-equiv\n".format(total_liabilities))
            f.write("- **Solvency Ratio:** {}\n".format(ratio_str))
            f.write("- **Net Delta:** {:.2f}%\n".format(net_delta * 100))
            f.write("- **Vault:** `{}`\n\n".format(self.vault_address))
            f.write("--- \n*Generated by Kerne PoR Bot (Institutional Hardening Mode)*")
            
        logger.success(f"Solvency report generated: {report_path}")
        return total_assets, off_chain_equity, net_delta

    def sign_attestation(self, off_chain_equity: float, net_delta: float, exchange_equity: float, timestamp: int):
        """
        Signs the reserve data using the bot's private key.
        Matches KerneVerificationNode.submitVerifiedAttestation signature.
        """
        assets_wei = self.w3.to_wei(off_chain_equity, 'ether')
        delta_wei = int(net_delta * 1e18)
        equity_wei = self.w3.to_wei(exchange_equity, 'ether')
        chain_id = self.w3.eth.chain_id

        message_hash = Web3.solidity_keccak(
            ['uint256', 'address', 'address', 'uint256', 'uint256', 'uint256', 'uint256'],
            [chain_id, self.verification_node_address, self.vault_address, assets_wei, delta_wei, equity_wei, timestamp]
        )
        encoded_message = encode_defunct(hexstr=message_hash.hex())
        signed_message = self.w3.eth.account.sign_message(encoded_message, private_key=self.private_key)
        return signed_message.signature.hex()

    def run_cycle(self):
        """
        Runs a single attestation cycle: Report -> Sign -> Publish -> Sync.
        """
        logger.info("Starting Institutional Solvency Pulse...")
        total_assets, off_chain_equity, net_delta = self.generate_solvency_report()
        
        timestamp = int(time.time())
        sig = self.sign_attestation(off_chain_equity, net_delta, off_chain_equity, timestamp)
        logger.info(f"Attestation Signed: {sig[:10]}...")

        if self.verification_node_address:
            try:
                # Load VerificationNode ABI
                node_abi = [
                    {
                        "inputs": [
                            {"internalType": "address", "name": "vault", "type": "address"},
                            {"internalType": "uint256", "name": "offChainAssets", "type": "uint256"},
                            {"internalType": "uint256", "name": "netDelta", "type": "uint256"},
                            {"internalType": "uint256", "name": "exchangeEquity", "type": "uint256"},
                            {"internalType": "uint256", "name": "timestamp", "type": "uint256"},
                            {"internalType": "bytes", "name": "signature", "type": "bytes"}
                        ],
                        "name": "submitVerifiedAttestation",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {"internalType": "uint32", "name": "_dstEid", "type": "uint32"},
                            {"internalType": "address", "name": "_vault", "type": "address"},
                            {"internalType": "bytes", "name": "_options", "type": "bytes"}
                        ],
                        "name": "syncAttestation",
                        "outputs": [],
                        "stateMutability": "payable",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {"internalType": "uint32", "name": "_dstEid", "type": "uint32"},
                            {"internalType": "address", "name": "_vault", "type": "address"},
                            {"internalType": "bytes", "name": "_options", "type": "bytes"},
                            {"internalType": "bool", "name": "_payInLzToken", "type": "bool"}
                        ],
                        "name": "quote",
                        "outputs": [
                            {
                                "components": [
                                    {"internalType": "uint256", "name": "nativeFee", "type": "uint256"},
                                    {"internalType": "uint256", "name": "lzTokenFee", "type": "uint256"}
                                ],
                                "internalType": "struct MessagingFee",
                                "name": "fee",
                                "type": "tuple"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    }
                ]
                node = self.w3.eth.contract(address=self.verification_node_address, abi=node_abi)
                
                assets_wei = self.w3.to_wei(off_chain_equity, 'ether')
                delta_wei = int(net_delta * 1e18)
                equity_wei = self.w3.to_wei(off_chain_equity, 'ether')

                # 1. Publish on Source Chain
                tx = node.functions.submitVerifiedAttestation(
                    self.vault_address,
                    assets_wei,
                    delta_wei,
                    equity_wei,
                    timestamp,
                    bytes.fromhex(sig[2:] if sig.startswith("0x") else sig)
                ).build_transaction({
                    'from': self.account.address,
                    'nonce': self.w3.eth.get_transaction_count(self.account.address),
                    'gas': 300000,
                    'gasPrice': self.w3.eth.gas_price
                })
                
                signed_tx = self.w3.eth.account.sign_transaction(tx, self.private_key)
                tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
                logger.success(f"Attestation published on-chain: {tx_hash.hex()}")

                # 2. Sync to Arbitrum if on Base
                chain_id = self.w3.eth.chain_id
                if chain_id == 8453: # Base
                    arb_eid = 30110
                    # Standard options for LZ V2 (executor gas limit)
                    # 0x00030100110100000000000000000000000000030d40 = 200k gas
                    options = bytes.fromhex("00030100110100000000000000000000000000030d40")
                    
                    # Wait a bit for the first tx to be indexed if needed, 
                    # but usually nonce management is enough.
                    
                    fee = node.functions.quote(arb_eid, self.vault_address, options, False).call()
                    native_fee = fee[0]
                    
                    sync_tx = node.functions.syncAttestation(
                        arb_eid,
                        self.vault_address,
                        options
                    ).build_transaction({
                        'from': self.account.address,
                        'nonce': self.w3.eth.get_transaction_count(self.account.address),
                        'value': native_fee,
                        'gas': 500000,
                        'gasPrice': self.w3.eth.gas_price
                    })
                    
                    signed_sync_tx = self.w3.eth.account.sign_transaction(sync_tx, self.private_key)
                    sync_tx_hash = self.w3.eth.send_raw_transaction(signed_sync_tx.rawTransaction)
                    logger.success(f"Attestation synced to Arbitrum: {sync_tx_hash.hex()}")

            except Exception as e:
                logger.error(f"Failed to publish or sync attestation: {e}")
        
        return total_assets

if __name__ == "__main__":
    bot = PoRAttestationBot()
    bot.run_cycle()
