import os
import json
import time
from web3 import Web3
from eth_account.messages import encode_defunct
from dotenv import load_dotenv
from loguru import logger
from exchange_manager import ExchangeManager

# Created: 2026-01-12
# Updated: 2026-01-13 (Automated Solvency Pulse)

class PoRAttestationBot:
    """
    Automated Proof of Reserve (PoR) Attestation Bot.
    Signs off-chain reserve data and publishes it for institutional transparency.
    """
    def __init__(self):
        load_dotenv()
        self.rpc_url = os.getenv("RPC_URL")
        self.private_key = os.getenv("PRIVATE_KEY")
        self.vault_address = os.getenv("VAULT_ADDRESS")
        self.verification_node_address = os.getenv("VERIFICATION_NODE_ADDRESS")
        
        if not all([self.rpc_url, self.private_key, self.vault_address]):
            logger.error("Missing environment variables for PoRAttestationBot.")
            raise ValueError("Missing RPC_URL, PRIVATE_KEY, or VAULT_ADDRESS")

        self.w3 = Web3(Web3.HTTPProvider(self.rpc_url))
        self.account = self.w3.eth.account.from_key(self.private_key)
        
        # Initialize ExchangeManager for Hyperliquid assets
        try:
            self.exchange = ExchangeManager()
        except Exception as e:
            logger.warning(f"Could not initialize ExchangeManager: {e}. Using 0 for off-chain assets.")
            self.exchange = None

        # Load Vault ABI for on-chain checks
        self.vault_abi = [
            {
                "inputs": [],
                "name": "totalSupply",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalAssets",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ]
        self.vault = self.w3.eth.contract(address=self.vault_address, abi=self.vault_abi)

    def get_total_protocol_assets(self):
        """
        Calculates total assets across on-chain vault and off-chain exchange.
        """
        on_chain_assets = self.vault.functions.totalAssets().call()
        
        off_chain_equity = 0
        if self.exchange:
            # Equity = Margin Balance + Unrealized PnL
            margin = self.exchange.get_collateral_balance()
            _, pnl = self.exchange.get_short_position("ETH")
            off_chain_equity = margin + pnl
            
        # In production, ensure decimals match (USDC vs ETH)
        return float(self.w3.from_wei(on_chain_assets, 'ether')) + float(off_chain_equity)

    def generate_solvency_report(self):
        """
        Generates a detailed solvency report and saves it to docs/reports/.
        """
        total_assets = self.get_total_protocol_assets()
        total_liabilities_wei = self.vault.functions.totalSupply().call()
        total_liabilities = float(self.w3.from_wei(total_liabilities_wei, 'ether'))
        
        status = "SOLVENT" if total_assets >= total_liabilities else "UNDERCOLLATERALIZED"
        
        if total_liabilities > 0:
            ratio_val = (total_assets / total_liabilities) * 100
            ratio_str = "{:,.2f}%".format(ratio_val)
        else:
            ratio_str = "1,000,000.00%+" if total_assets > 0 else "100.00%"

        report_path = os.path.join("docs", "reports", f"solvency_report_{time.strftime('%Y_%m_%d')}.md")
        os.makedirs(os.path.dirname(report_path), exist_ok=True)
        
        # Use a local variable for the date to ensure consistency
        report_date = time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime())
        
        with open(report_path, "w") as f:
            f.write("# Kerne Solvency Report - {}\n\n".format(report_date))
            f.write("**Status:** {}\n\n".format(status))
            f.write("- **Total Assets:** {:.4f} ETH-equiv\n".format(total_assets))
            f.write("- **Total Liabilities:** {:.4f} ETH-equiv\n".format(total_liabilities))
            f.write("- **Solvency Ratio:** {}\n".format(ratio_str))
            f.write("- **Vault:** `{}`\n\n".format(self.vault_address))
            f.write("--- \n*Generated by Kerne PoR Bot*")
            
        logger.success(f"Solvency report generated: {report_path}")
        return total_assets

    def sign_attestation(self, total_assets_eth: float, timestamp: int):
        """
        Signs the reserve data using the bot's private key.
        """
        message_hash = Web3.solidity_keccak(
            ['address', 'uint256', 'uint256'],
            [self.vault_address, self.w3.to_wei(total_assets_eth, 'ether'), timestamp]
        )
        encoded_message = encode_defunct(hexstr=message_hash.hex())
        signed_message = self.w3.eth.account.sign_message(encoded_message, private_key=self.private_key)
        return signed_message.signature.hex()

    def run_cycle(self):
        """
        Runs a single attestation cycle: Report -> Sign -> (Optional) Publish.
        """
        logger.info("Starting Automated Solvency Pulse...")
        total_assets = self.generate_solvency_report()
        
        # For now, we sign and log. On-chain publication requires VerificationNode deployment.
        timestamp = int(time.time())
        sig = self.sign_attestation(total_assets, timestamp)
        logger.info(f"Attestation Signed: {sig[:10]}...")
        
        return total_assets

if __name__ == "__main__":
    bot = PoRAttestationBot()
    bot.run_cycle()
