// Created: 2026-01-21
/**
 * Kerne Protocol - Proof of Reserve API Handler
 * 
 * Serves the latest PoR attestation data from the bot-generated JSON file.
 * This provides the public "Glass House Standard" endpoint for institutional verification.
 * 
 * Endpoint: GET /api/proof-of-reserve
 * 
 * Response: {
 *   generated_at: "2026-01-21T00:00:00Z",
 *   total_assets_eth: 1.234567,
 *   total_liabilities_eth: 1.000000,
 *   aggregate_solvency_ratio: 1.234567,
 *   is_solvent: true,
 *   status: "SOLVENT",
 *   attestation_hash: "0x...",
 *   signature: "0x...",
 *   signer: "0x...",
 *   chains: [...],
 *   ...
 * }
 */

import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import * as fs from 'fs';
import * as path from 'path';

// Path to the PoR JSON file (generated by bot/por_automated.py)
const POR_FILE_PATH = process.env.POR_FILE_PATH || '../docs/reports/por/latest.json';

interface ChainMetrics {
  chain_id: number;
  chain_name: string;
  vault_address: string;
  total_assets_eth: number;
  total_supply_eth: number;
  solvency_ratio: number;
  rpc_healthy: boolean;
  timestamp: number;
}

interface ProofOfReserve {
  generated_at: string;
  unix_timestamp: number;
  block_heights: Record<string, number>;
  chains: ChainMetrics[];
  total_onchain_assets_eth: number;
  total_onchain_liabilities_eth: number;
  offchain_venue: string;
  offchain_equity_usd: number;
  offchain_equity_eth_equiv: number;
  offchain_net_delta: number;
  offchain_short_position_eth: number;
  total_assets_eth: number;
  total_liabilities_eth: number;
  aggregate_solvency_ratio: number;
  is_solvent: boolean;
  delta_neutral: boolean;
  attestation_hash: string;
  signature: string;
  signer: string;
  status: string;
}

/**
 * Loads the latest PoR from the JSON file.
 * Returns null if file doesn't exist or is invalid.
 */
function loadLatestPoR(): ProofOfReserve | null {
  try {
    // Try multiple paths (local dev vs production)
    const possiblePaths = [
      POR_FILE_PATH,
      path.join(__dirname, '../../..', 'docs/reports/por/latest.json'),
      path.join(process.cwd(), 'docs/reports/por/latest.json'),
      '/app/docs/reports/por/latest.json', // Docker path
    ];

    for (const filePath of possiblePaths) {
      if (fs.existsSync(filePath)) {
        const rawData = fs.readFileSync(filePath, 'utf-8');
        return JSON.parse(rawData) as ProofOfReserve;
      }
    }

    return null;
  } catch (error) {
    console.error('Error loading PoR file:', error);
    return null;
  }
}

/**
 * Calculate staleness of the PoR data.
 * Returns true if the attestation is more than 25 hours old.
 */
function isStale(por: ProofOfReserve): boolean {
  const nowSeconds = Math.floor(Date.now() / 1000);
  const ageSeconds = nowSeconds - por.unix_timestamp;
  const maxAgeSeconds = 25 * 60 * 60; // 25 hours (allowing 1 hour buffer on daily)
  return ageSeconds > maxAgeSeconds;
}

/**
 * Main handler for GET /api/proof-of-reserve
 */
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  // CORS headers
  const headers = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, OPTIONS',
    'Cache-Control': 'public, max-age=300', // Cache for 5 minutes
  };

  // Handle OPTIONS preflight
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers,
      body: '',
    };
  }

  try {
    const por = loadLatestPoR();

    if (!por) {
      return {
        statusCode: 503,
        headers,
        body: JSON.stringify({
          error: 'PoR data not available',
          message: 'Proof of Reserve attestation has not been generated yet. Please try again later.',
          hint: 'Run `python por_automated.py` to generate initial attestation.',
        }),
      };
    }

    // Add metadata
    const stale = isStale(por);
    const response = {
      ...por,
      _metadata: {
        api_version: '1.0.0',
        is_stale: stale,
        stale_warning: stale
          ? 'This attestation is over 25 hours old. The daily PoR job may have failed.'
          : null,
        verification_instructions: {
          step1: 'Hash the JSON data (excluding signature and _metadata) using SHA256',
          step2: 'Verify the signature using ecrecover(attestation_hash, signature)',
          step3: `Expected signer: ${por.signer}`,
        },
        endpoints: {
          latest: '/api/proof-of-reserve',
          history: '/api/proof-of-reserve/history',
        },
      },
    };

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(response, null, 2),
    };
  } catch (error) {
    console.error('Error in proofOfReserve handler:', error);
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error',
      }),
    };
  }
};

/**
 * Handler for GET /api/proof-of-reserve/history
 * Returns list of historical PoR attestations.
 */
export const historyHandler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  const headers = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, OPTIONS',
    'Cache-Control': 'public, max-age=3600', // Cache for 1 hour
  };

  if (event.httpMethod === 'OPTIONS') {
    return { statusCode: 200, headers, body: '' };
  }

  try {
    // List files in history directory
    const historyDir = path.join(process.cwd(), 'docs/reports/por/history');
    
    if (!fs.existsSync(historyDir)) {
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({ attestations: [], count: 0 }),
      };
    }

    const files = fs.readdirSync(historyDir)
      .filter(f => f.endsWith('.json'))
      .sort()
      .reverse()
      .slice(0, 30); // Last 30 attestations

    const attestations = files.map(file => {
      const filePath = path.join(historyDir, file);
      const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
      return {
        generated_at: data.generated_at,
        status: data.status,
        solvency_ratio: data.aggregate_solvency_ratio,
        total_assets_eth: data.total_assets_eth,
        attestation_hash: data.attestation_hash,
      };
    });

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        attestations,
        count: attestations.length,
        oldest_available: attestations[attestations.length - 1]?.generated_at,
        newest_available: attestations[0]?.generated_at,
      }, null, 2),
    };
  } catch (error) {
    console.error('Error in history handler:', error);
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error',
      }),
    };
  }
};

export default handler;
